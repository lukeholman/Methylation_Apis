---
title: "Analysis of the RNA-seq data"
output: 
  workflowr::wflow_html:
    code_folding: hide 
---


## Load R packages and the expression data
```{r pkgs, results='hide', message=FALSE, warning=FALSE}
# All but 1 of these packages can be easily installed from CRAN or Bioconductor
# However it was slightly harder to install the showtext package. On Mac, I did this:
# installed 'homebrew' using Terminal: ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)" 
# installed 'libpng' using Terminal: brew install libpng
# installed 'showtext' in R using: devtools::install_github("yixuan/showtext")  
library(showtext)

# Run these to install from Bioconductor:
# BiocManager::install("AnnotationHub") 
# BiocManager::install("edgeR")
# BiocManager::install("clusterProfiler")
# BiocManager::install("WGCNA")
library(tidyverse)
library(brms)
library(edgeR) # install with BiocManager::install("edgeR") 
library(dbplyr)
library(DBI)
library(RSQLite)
library(gplots)
library(gridExtra)
library(ecodist)
library(WGCNA) # 
library(clusterProfiler) 
library(RColorBrewer)
library(pander)
library(kableExtra)
library(DT)
library(reshape2)
library(UpSetR)
library(pheatmap)
library(RColorBrewer)
library(ggrepel)
library(broom)
library(fgsea) # for enrichment tests; source("https://bioconductor.org/biocLite.R"); biocLite("fgsea") 


# set up nice font for figure
nice_font <- "Lora"
font_add_google(name = nice_font, family = nice_font, regular.wt = 400, bold.wt = 700)
showtext_auto()

# define colours
queen_colour <- "#d13b40"
worker_colour <- RColorBrewer::brewer.pal(7, "Blues")[4]


kable_table <- function(df) {
  kable(df, "html") %>%
  kable_styling() %>%
  scroll_box(height = "300px")
}

# Database with useful gene name conversion table, GO terms etc.
db <- dbConnect(SQLite(), "data/apis_db.sqlite3") # DBI::dbListTables(db)

# Load the RSEM expression_data for each sample-gene combination
expression_data <- as.matrix(read.table("data/Expression_data/Genes_2020_version.txt", row.names = 1, header = T))
n_genes_before_filtering <- nrow(expression_data)
gsg <- goodSamplesGenes(t(expression_data), verbose = 3) # exclude 217 genes due to too many missing samples or zero variance
expression_data <- expression_data[gsg$goodGenes, gsg$goodSamples]

# tibble(isoform_id = c("NM_001111255.1", "NM_001134935.1", "NM_001134936.1", "NR_024131.1" ,"XM_006560013.2"), 
#        description = c("Male", "F2", "B", "RNA", "X1"))
# NM_001111255.1 = male form Dsx
# NR_024131.1 = DSX transcript variant F1
# NM_001134935.1 = DSX transcript variant F2
# NM_001134936.1 = transcript variant B



# Extract key information from the sample names
sample_ids <- data.frame(
  sample_name = colnames(expression_data),
  caste = ifelse(grepl("w", colnames(expression_data)), "Worker", "Queen"),
  time_point = str_extract(colnames(expression_data), "[02468]"),
  replicate = gsub("_", "", str_extract(colnames(expression_data), "_[ABCD]")),
  stringsAsFactors = TRUE) %>%
  mutate(caste = replace(as.character(caste), str_detect(colnames(expression_data), "t0"), "Time zero"),
         #time_point = as.numeric(as.character(time_point)),
         time_point = relevel(factor(time_point), ref = 2),
         queen_cell = ifelse(caste == "Queen","Yes", "No"),
         worker_cell = ifelse(caste == "Worker", "Yes", "No"))
```

```{r echo = FALSE}
# knitr::opts_chunk$set(cache = TRUE)
# knitr::opts_chunk$set(autodep = TRUE)
```



## Data checks and pre-processing

### Filter out low-expression genes
```{r filter_genes}
# filter genes for which maximum expression level is less than 1 Count Per Million 
voom_gene_data <- calcNormFactors(DGEList(expression_data))
voom_gene_data <- voom_gene_data[-which(apply(cpm(voom_gene_data), 1, max) < 1),] 

genes_kept <- rownames(voom_gene_data@.Data[[1]])
expression_data <- expression_data[rownames(expression_data) %in% genes_kept, ]
n_genes_after_filtering <- unique(c(nrow(voom_gene_data), nrow(expression_data)))

tibble(` ` = c("Number of transcripts prior to filtering:", 
               "Number remaining after filtering out transcripts where max(CPM) < 1 or too many samples are missing:"),
       n = c(n_genes_before_filtering, n_genes_after_filtering)) %>% pander()
```

### Plot the transcriptomes using NMDS {.tabset}

#### Before removing the batch effects
```{r nmds1}
nmds_output <- dist(t(expression_data)) %>% nmds(maxdim = 2)
nmds_r2 <- tail(nmds_output$r2, 1)
nmds_output <- data.frame(Caste = sample_ids$caste,
                          Time = as.numeric(as.character(sample_ids$time_point)),
                          Replicate = sample_ids$replicate,
                          label = paste(sample_ids$caste, sample_ids$time_point),
                          nmds_output$conf[[length(nmds_output$conf)]])

nmds_output %>%
  mutate_at(vars(starts_with("X")), ~ as.numeric(scale(.x))) %>%
  gather(NMDS, Score, starts_with("X")) %>%
  mutate(NMDS = gsub("X", "NMDS ", NMDS),
         Replicate = paste("Replicate", Replicate)) %>%
  ggplot(aes(Time, Score, colour = Caste, group = Caste)) + 
  geom_line() +
  geom_point() + 
  scale_colour_manual(values = c(queen_colour, "black", worker_colour), 
                      name = "Cell type") + 
  facet_grid(NMDS~Replicate) + 
  xlab("Time since the larva was grafted (hours)")
```

**Figure**: Results of non-metric multidimensional scaling analysis, which reduces the distance matrix between samples to two dimensions (here termed NMDS 1 and 2; $r^2 =$ `r nmds_r2`). The plot suggests that queen- and worker-destined larvae have different gene expression profiles, that the transcriptome changes over time, and that the caste difference becomes larger with time since grafting. 



#### After removing the batch effects
```{r nmds2}
expression_no_batch_effect <- limma::removeBatchEffect(expression_data, 
                                                batch = sample_ids$replicate)
set.seed(12345)
nmds_output <- dist(t(expression_no_batch_effect)) %>% nmds(maxdim = 2)
nmds_r2 <- tail(nmds_output$r2, 1)
nmds_output <- data.frame(Caste = sample_ids$caste,
                          Time = as.numeric(as.character(sample_ids$time_point)),
                          Replicate = sample_ids$replicate,
                          label = paste(sample_ids$caste, sample_ids$time_point),
                          nmds_output$conf[[length(nmds_output$conf)]])

nmds_output %>%
  mutate_at(vars(starts_with("X")), ~ as.numeric(scale(.x))) %>%
  gather(NMDS, Score, starts_with("X")) %>%
  mutate(NMDS = gsub("X", "NMDS ", NMDS),
         Replicate = paste("Replicate", Replicate)) %>%
  ggplot(aes(Time, Score, colour = Caste, group = Caste)) + 
  geom_line() +
  geom_point() + 
  scale_colour_manual(values = c(queen_colour, "black", worker_colour), 
                      name = "Cell type") + 
  facet_grid(NMDS~Replicate) + 
  xlab("Time since the larva was grafted (hours)")
```

**Figure**: Results of non-metric multidimensional scaling analysis, after removing the batch effects using `limma::removeBatchEffect`.


## Exploratory plots of the transcriptome data

### Euclidean distance matrix of all samples

Darker colours indicate pairs of samples that have more different transcriptomes. The samples are clustered (using hierarchical clustering), and the cluster tree has been cut into 5 maximally-distinct units (by `stats::cutree()`) to make it easier to spot groups of samples that cluster together. 

```{r euclid, fig.height=8.5}
sampleDistMatrix <- (as.matrix(dist(t(expression_no_batch_effect))))
colors1 <- colorRampPalette( (brewer.pal(9, "YlOrBr")) )(255)
colors2 <- colorRampPalette( c(rev(brewer.pal(9, "Blues")),
                               "white", brewer.pal(9, "Reds")) )(255)

name_converter <- sample_ids %>%
  mutate(new_name = paste(caste, " ", time_point, "h rep", replicate, sep = ""),
         new_name = str_replace_all(new_name, " 0h", "")) %>%
  dplyr::select(sample_name, new_name)

rownames(sampleDistMatrix) <- name_converter$new_name[match(rownames(sampleDistMatrix), name_converter$sample_name)]
colnames(sampleDistMatrix) <- name_converter$new_name[match(colnames(sampleDistMatrix), name_converter$sample_name)]

sampleDistMatrix %>%
  pheatmap(col = colors1, legend = FALSE,
           cutree_rows = 5, cutree_cols = 5)
```


### Heatmap clustering samples and transcripts

Samples don't cluster perfectly (e.g. there is one 2h Worker sample clustering with some 6h and 8h Queen samples), though overall there is evident differentiation by caste and time. The 'transcriptional modules' that we later analyse using WGCNA are also apparent. The colour shows gene expression level from RSEM, scaled to have a mean of zero and unit variance across all samples.

```{r bigheatmap, fig.height=12}
scaled_no_batch_effect <- expression_no_batch_effect
for(i in 1:nrow(expression_no_batch_effect)) {
  scaled_no_batch_effect[i,] <- as.numeric(scale(expression_no_batch_effect[i, ]))
}
rownames(scaled_no_batch_effect) <- NULL
colnames(scaled_no_batch_effect) <- name_converter$new_name[match(colnames(scaled_no_batch_effect), name_converter$sample_name)]

paletteLength <- 50
myColor <- colorRampPalette(c(brewer.pal(9, "Blues")[7], "white", brewer.pal(9, "Reds")[7]))(paletteLength)
myBreaks <- c(seq(min(scaled_no_batch_effect, na.rm=T), 0, length.out=ceiling(paletteLength/2) + 1), 
              seq(max(scaled_no_batch_effect, na.rm=T)/paletteLength, max(scaled_no_batch_effect, na.rm=T), length.out=floor(paletteLength/2)))

scaled_no_batch_effect %>%
  pheatmap(color = myColor, breaks = myBreaks, 
           cutree_cols = 5, 
           labels_row = NULL)
```


## Detecting differential expression with `limma::voom`

### Run the linear models

The formula used for the linear models is: `caste * time_point + replicate`. We then use this model to compute planned contrasts that test for a caste difference at each time point (2h, 4h, 6h, 8h), as well as to measure the ccaste-specific effect of time on gene expression (e.g. we test for changes in expression between 2h and 8h, separately in queens and workers).

In the following tables, a **positive** log fold change in expression indicates **higher expression in queens** vs workers (for caste comparisons) or **higher expression at later times** than earlier times (for temporal comparisons).

```{r voom}
voom_gene_data <- calcNormFactors(DGEList(expression_data))

# Set up model matrix. NB "replicate" is treated with sum constrasts, since no one replicate is 
# a meaningful comparison point (we use time 2h as the baseline for time, and queens as basis for caste)
mm <- model.matrix(~ queen_cell * time_point + replicate, 
                   data = sample_ids , 
                   contrasts = list(replicate = "contr.sum")) 

mm <- mm[, !grepl("queen_cellYes:time_point0", colnames(mm))]

colnames(mm) <- gsub("caste", "", colnames(mm))
voom_gene_fit <- voom_gene_data %>% voom(mm, plot = FALSE) %>% lmFit(mm)

contrast_matrix <- cbind(
  Time_zero = c(1,0,1,0,0,0,0,0,0,0,0,0),
  Queen_2 =   c(1,1,0,0,0,0,0,0,0,0,0,0),
  Queen_4 =   c(1,1,0,1,0,0,0,0,0,1,0,0),
  Queen_6 =   c(1,1,0,0,1,0,0,0,0,0,1,0),
  Queen_8 =   c(1,1,0,0,0,1,0,0,0,0,0,1),
  
  Worker_2 =   c(1,0,0,0,0,0,0,0,0,0,0,0),
  Worker_4 =   c(1,0,0,1,0,0,0,0,0,0,0,0),
  Worker_6 =   c(1,0,0,0,1,0,0,0,0,0,0,0),
  Worker_8 =   c(1,0,0,0,0,1,0,0,0,0,0,0)) %>% 
  as.data.frame() %>%
  mutate(
    Caste_2 = Queen_2 - Worker_2,
    Caste_4 = Queen_4 - Worker_4,
    Caste_6 = Queen_6 - Worker_6,
    Caste_8 = Queen_8 - Worker_8,
    
    Queen_0vs2 = Queen_2 - Time_zero,
    Queen_0vs4 = Queen_4 - Time_zero,
    Queen_0vs6 = Queen_6 - Time_zero,
    Queen_0vs8 = Queen_8 - Time_zero,
    
    Queen_2vs4 = Queen_4 - Queen_2,
    Queen_2vs6 = Queen_6 - Queen_2,
    Queen_2vs8 = Queen_8 - Queen_2,
    
    Queen_4vs6 = Queen_6 - Queen_4,
    Queen_4vs8 = Queen_8 - Queen_4,
    
    Queen_6vs8 = Worker_2 - Queen_6,
    
    Worker_0vs2 = Worker_2 - Time_zero,
    Worker_0vs4 = Worker_4 - Time_zero,
    Worker_0vs6 = Worker_6 - Time_zero,
    Worker_0vs8 = Worker_8 - Time_zero,
    
    Worker_2vs4 = Worker_4 - Worker_2,
    Worker_2vs6 = Worker_6 - Worker_2,
    Worker_2vs8 = Worker_8 - Worker_2,
    
    Worker_4vs6 = Worker_6 - Worker_4,
    Worker_4vs8 = Worker_8 - Worker_4,
    
    Worker_6vs8 = Worker_8 - Worker_6)



get_results <- function(voom_fit, column){
  voom_fit %>%
    contrasts.fit(contrast_matrix[, names(contrast_matrix) == column]) %>%
    eBayes() %>%
    topTable(n = Inf) %>% 
    rownames_to_column("Gene")
}

caste_results <- rbind(
  get_results(voom_gene_fit, "Caste_2") %>% mutate(Time = 2),
  get_results(voom_gene_fit, "Caste_4") %>% mutate(Time = 4),
  get_results(voom_gene_fit, "Caste_6") %>% mutate(Time = 6),
  get_results(voom_gene_fit, "Caste_8") %>% mutate(Time = 8)) %>%
  left_join(tbl(db, "gene_names") %>% 
              dplyr::select(gene_symbol, gene_name) %>% 
              collect(n=Inf), 
            by = c("Gene" = "gene_symbol")) %>%
  rename(`Gene name` = gene_name,
         `Gene symbol` = Gene) %>%
  as_tibble() %>% select(Time, `Gene symbol`, `Gene name`, everything()) 

time_results <- rbind(
  get_results(voom_gene_fit, "Queen_0vs2") %>% 
    mutate(Caste = "Queen", Time = "0 vs 2"),
  get_results(voom_gene_fit, "Queen_0vs4") %>% 
    mutate(Caste = "Queen", Time = "0 vs 4"),
  get_results(voom_gene_fit, "Queen_0vs6") %>% 
    mutate(Caste = "Queen", Time = "0 vs 6"),
  get_results(voom_gene_fit, "Queen_0vs8") %>% 
    mutate(Caste = "Queen", Time = "0 vs 8"),
  get_results(voom_gene_fit, "Queen_2vs4") %>% 
    mutate(Caste = "Queen", Time = "2 vs 4"),
  get_results(voom_gene_fit, "Queen_2vs6") %>% 
    mutate(Caste = "Queen", Time = "2 vs 6"),
  get_results(voom_gene_fit, "Queen_2vs8") %>% 
    mutate(Caste = "Queen", Time = "2 vs 8"),
  get_results(voom_gene_fit, "Queen_4vs6") %>% 
    mutate(Caste = "Queen", Time = "4 vs 6"),
  get_results(voom_gene_fit, "Queen_4vs8") %>% 
    mutate(Caste = "Queen", Time = "4 vs 8"),
  get_results(voom_gene_fit, "Queen_6vs8") %>% 
    mutate(Caste = "Queen", Time = "6 vs 8"),
  
  get_results(voom_gene_fit, "Worker_0vs2") %>% 
    mutate(Caste = "Worker", Time = "0 vs 2"),
  get_results(voom_gene_fit, "Worker_0vs4") %>% 
    mutate(Caste = "Worker", Time = "0 vs 4"),
  get_results(voom_gene_fit, "Worker_0vs6") %>% 
    mutate(Caste = "Worker", Time = "0 vs 6"),
  get_results(voom_gene_fit, "Worker_0vs8") %>% 
    mutate(Caste = "Worker", Time = "0 vs 8"),
  get_results(voom_gene_fit, "Worker_2vs4") %>% 
    mutate(Caste = "Worker", Time = "2 vs 4"),
  get_results(voom_gene_fit, "Worker_2vs6") %>% 
    mutate(Caste = "Worker", Time = "2 vs 6"),
  get_results(voom_gene_fit, "Worker_2vs8") %>% 
    mutate(Caste = "Worker", Time = "2 vs 8"),
  get_results(voom_gene_fit, "Worker_4vs6") %>% 
    mutate(Caste = "Worker", Time = "4 vs 6"),
  get_results(voom_gene_fit, "Worker_4vs8") %>% 
    mutate(Caste = "Worker", Time = "4 vs 8"),
  get_results(voom_gene_fit, "Worker_6vs8") %>% 
    mutate(Caste = "Worker", Time = "6 vs 8")) %>%
  left_join(tbl(db, "gene_names") %>% 
              select(gene_symbol, gene_name) %>% 
              collect(n=Inf), 
            by = c("Gene" = "gene_symbol")) %>%
  rename(`Gene name` = gene_name,
         `Gene symbol` = Gene) %>%
  as_tibble() %>% 
  select(Caste, Time, `Gene symbol`, `Gene name`, everything())
```


```{r eval=F}
corrrs <- cor(t(expression_data), method = "spearman") %>%
  as.data.frame() %>%
  rownames_to_column("other_gene") %>% as_tibble() %>%
  gather(focal_gene, correlation, -other_gene) %>%
  filter(focal_gene != other_gene) %>% select(focal_gene, other_gene, correlation)

plot_corr_hist <- function(genes){
  corrrs %>%
    filter(focal_gene %in% genes) %>%
    ggplot(aes(correlation)) + 
    geom_histogram(bins = 100) + 
    scale_x_continuous(limits = c(-1,1)) + 
    facet_wrap(~ focal_gene)
}

plot_corr_hist(c("Vg", "Dnmt1a", "Dnmt3", "Dsx", "LOC413289", "tra2", "Mrjp1", "Mrjp2", "5-HT1"))
# 
# median_corrs <- corrrs %>%
#   group_by(focal_gene) %>%
#   summarise(median_corr = mean(correlation)) %>%
#   arrange(median_corr)
# 
# median_corrs %>%
#   left_join(caste_results %>% filter(Time ==8), by = c("focal_gene" = "Gene symbol")) %>% 
#   ggplot(aes(median_corr, logFC)) + 
#   geom_point()
# 
# rand <- corrrs$focal_gene[sample(nrow(corrrs), 25)] %>%sort()
# plot_corr_hist("LOC724565")
# 
# tbl(db, "gene_names") %>% filter(gene_symbol == "LOC724565")
```


## Significantly differentially expressed gene lists

### Caste-specific genes

You can also view this table on a full web page [here](caste_table.html), or press the buttons to export the table to PDF, .csv, or Excel formats.

```{r intersections}
get_intersections <- function(results_df, split_by){
  results_df <- results_df %>%
    mutate(Gene = paste(`Gene symbol`, `Gene name`, sep = "~~")) %>%
    filter(adj.P.Val <= 0.05)
  splitter <- results_df %>% pull(!! split_by)
  sig_genes <- results_df %>%
    pull(`Gene`) %>%
    split(splitter)
  
  names(sig_genes) <- unique(splitter)
  ven <- venn(sig_genes, show.plot = FALSE)
  attr(ven, "intersections")
}


get_intersections(caste_results, "Time") %>% melt() %>% 
  mutate(
    `Hour(s) with a significant caste difference:` = gsub(":", ", ", L1),
    split = strsplit(as.character(value), split = "~~"),
    `Gene symbol` = map_chr(split, ~ .x[1]),
    `Gene name` = map_chr(split, ~ .x[2])) %>% 
  select(`Gene symbol`, `Gene name`, 
         `Hour(s) with a significant caste difference:`) %>% 
  as_tibble() %>%
  left_join(
    caste_results %>%
      select(`Gene symbol`, Time, logFC) %>%
      distinct() %>%
      spread(Time, logFC) %>%
      rename_at(vars(-`Gene symbol`), ~ paste("logFC at ", .x, "h", sep = "")),
    by = "Gene symbol") %>%
  arrange(-abs(`logFC at 2h` + `logFC at 4h` + `logFC at 6h` + `logFC at 8h`)) %>%
  mutate_at(vars(starts_with("logFC")), ~ round(.x, 2)) %>%
  # datatable(options = list(pageLength = 10), rownames = FALSE, filter = 'top', fillContainer = TRUE)
  datatable(rownames = FALSE, filter = 'top', fillContainer = TRUE,
            extensions = 'Buttons', options = list(
              dom = 'Bfrtip', pageLength = 10,
              buttons = c('copy', 'csv', 'excel', 'pdf')))
            
            
            
```

### Temporally-variable genes in queen-destined larvae

You can also view this table on a full web page [here](queen_time_table.html), or press the buttons to export the table to PDF, .csv, or Excel formats.

```{r temporal_Q}
time_results %>% 
  filter(Caste == "Queen") %>%
  get_intersections("Time") %>% 
  melt() %>% 
  mutate(
    `Significant temporal comparisons:` = gsub(":", "; ", L1),
    split = strsplit(as.character(value), split = "~~"),
    `Gene symbol` = map_chr(split, ~ .x[1]),
    `Gene name` = map_chr(split, ~ .x[2])) %>% 
  select(`Gene symbol`, `Gene name`, `Significant temporal comparisons:`) %>% 
  arrange(-nchar(`Significant temporal comparisons:`),
          `Significant temporal comparisons:`) %>% as_tibble() %>%
  left_join(
    time_results %>%
      filter(Caste == "Queen") %>%
      select(`Gene symbol`, Time, logFC) %>%
      distinct() %>%
      spread(Time, logFC) %>%
      rename_at(vars(-`Gene symbol`), ~ paste("logFC: ", .x, "h", sep = "")),
    by = "Gene symbol") %>%
  mutate_at(vars(starts_with("logFC")), ~ round(.x, 2)) %>%
  # datatable(options = list(pageLength = 10), rownames = FALSE, filter = 'top', fillContainer = TRUE)
  datatable(rownames = FALSE, filter = 'top', fillContainer = TRUE,
            extensions = 'Buttons', options = list(
              dom = 'Bfrtip', pageLength = 10,
              buttons = c('copy', 'csv', 'excel', 'pdf')))
```

### Temporally-variable genes in worker-destined larvae

You can also view this table on a full web page [here](worker_time_table.html), or press the buttons to export the table to PDF, .csv, or Excel formats.

```{r temporal_W}
time_results %>% 
  filter(Caste == "Worker") %>%
  get_intersections("Time") %>% 
  melt() %>% 
  mutate(
    `Significant temporal comparisons:` = gsub(":", "; ", L1),
    split = strsplit(as.character(value), split = "~~"),
    `Gene symbol` = map_chr(split, ~ .x[1]),
    `Gene name` = map_chr(split, ~ .x[2])) %>% 
  select(`Gene symbol`, `Gene name`, `Significant temporal comparisons:`) %>% 
  arrange(-nchar(`Significant temporal comparisons:`),
          `Significant temporal comparisons:`) %>% as_tibble() %>%
  left_join(
    time_results %>%
      filter(Caste == "Queen") %>%
      select(`Gene symbol`, Time, logFC) %>%
      distinct() %>%
      spread(Time, logFC) %>%
      rename_at(vars(-`Gene symbol`), ~ paste("logFC: ", .x, "h", sep = "")),
    by = "Gene symbol") %>%
  mutate_at(vars(starts_with("logFC")), ~ round(.x, 2)) %>%
  # datatable(options = list(pageLength = 10), rownames = FALSE, filter = 'top', fillContainer = TRUE)
  datatable(rownames = FALSE, filter = 'top', fillContainer = TRUE,
            extensions = 'Buttons', options = list(
              dom = 'Bfrtip', pageLength = 10,
              buttons = c('copy', 'csv', 'excel', 'pdf')))
```


## Overlaps in differential expression

### UpSet plot

The plot shows the number of significantly differentially expressed genes for each comparison, and the number of these that intersect for each pair of comparisons (similar to a Venn diagram, expect it can handle more categories).

```{r upset, fig.height=7}
caste_results %>% 
  mutate(Caste = "Caste difference", 
         Time = paste(Time, "h", sep = "")) %>% 
  select(Caste, Time, `Gene symbol`, 
         `Gene name`, adj.P.Val) %>%
  bind_rows(
    time_results %>% 
      select(Caste, Time, `Gene symbol`, 
             `Gene name`, adj.P.Val) %>%
      mutate(Time = paste(
        substr(Time,1,1), 
        "h", substr(Time,2,nchar(Time)), "h", sep = ""))) %>%
  filter(adj.P.Val <= 0.05) %>% 
  mutate(Comparison = paste(Caste, Time)) %>%
  split(.$Comparison) %>%
  map(~ .x %>% pull(`Gene symbol`)) %>%
  fromList() %>%
  upset(order.by = "freq", nsets = 999) 
```

### Correlations in log fold differences in expression

The figure plots each possible pairwise comparison for within and between castes, e.g. the Queen 6 vs 8 variable gives the log fold difference in gene expression that was estimated between the 6h and 8h queen samples that was estimated by `voom`. Note that many of the genes that increased in expression at times 0-6h in queens, and also genes in which queens have higher expression than workers, actually decrease in expression between 6h and 8h in queens (one can also see this in the eigengenes figure below). 

```{r cor_lfc, warning=FALSE, fig.height=10, fig.width=12}
corr_mat <- (
  caste_results %>% 
    mutate(Caste = "Queen vs worker", 
           Time = as.character(Time)) %>% 
    select(Caste, Time, `Gene symbol`, `Gene name`, logFC) %>%
    bind_rows(time_results %>% 
                select(Caste, Time, `Gene symbol`, `Gene name`, logFC)) %>%
    mutate(Comparison = paste(Caste, Time)) %>% 
    select(`Gene symbol`, Comparison, logFC) %>% distinct() %>%
    spread(Comparison, logFC) %>% select(-`Gene symbol`)) %>%
  cor()

pheatmap(corr_mat, col = colors2, 
         cutree_cols = 4, 
         cutree_rows = 4, 
         labels_row = NULL)
```


## Enriched pathways among the caste-biased genes 

### Code to run GO and KEGG enrichment

```{r GO_and_KEGG_gsea, warning = FALSE, fig.height=10.1, fig.width = 5.3}
source("code/GO_and_KEGG_gsea.R")

# Run all the enrichment tests:
if(!file.exists("output/expr_gsea_results.rds")){
  
  # Load up the voom differential expression results
  caste_GO_data <- read_csv("output/caste_results.csv") %>%
    dplyr::rename(gene = `Gene symbol`,
                  statistic = logFC) %>%
    dplyr::select(gene, statistic, Time) 
  
  time_GO_data <- read_csv("output/time_results.csv") %>%
    dplyr::rename(gene = `Gene symbol`,
                  statistic = logFC) %>%
    dplyr::select(gene, statistic, Caste, Time) 
  
  # Do the GO and KEGG enrichments (see the file code/GO_and_KEGG_gsea.R)
  
  # Caste difference, at each time point (A. mellifera annotations)
  GO_Amel_annotations_caste <- rbind(
    caste_GO_data %>% filter(Time == 2) %>%                    
      GO_and_KEGG_gsea(keep.all = TRUE, GO_list = "bee_GO") %>% 
      mutate(Time = 2, Comparison = "Caste"),
    caste_GO_data %>% filter(Time == 4) %>%    
      GO_and_KEGG_gsea(keep.all = TRUE, GO_list = "bee_GO") %>% 
      mutate(Time = 4, Comparison = "Caste"),
    caste_GO_data %>% filter(Time == 6) %>%    
      GO_and_KEGG_gsea(keep.all = TRUE, GO_list = "bee_GO") %>% 
      mutate(Time = 6, Comparison = "Caste"),
    caste_GO_data %>% filter(Time == 8) %>%    
      GO_and_KEGG_gsea(keep.all = TRUE, GO_list = "bee_GO") %>% 
      mutate(Time = 8, Comparison = "Caste")
  ) 
  significant <- GO_Amel_annotations_caste %>% filter(pval < 0.05) %>% pull(pathway) %>% unique()
  GO_Amel_annotations_caste <- GO_Amel_annotations_caste %>%
    filter(pathway %in% significant)
  
  
  # Caste difference, at each time point (D. melanogaster annotations)
  GO_Dmel_annotations_caste <- rbind(
    caste_GO_data %>% filter(Time == 2) %>%    
      GO_and_KEGG_gsea(keep.all = TRUE, GO_list = "dros_ortho_GO") %>% 
      mutate(Time = 2, Comparison = "Caste"),
    caste_GO_data %>% filter(Time == 4) %>%    
      GO_and_KEGG_gsea(keep.all = TRUE, GO_list = "dros_ortho_GO") %>% 
      mutate(Time = 4, Comparison = "Caste"),
    caste_GO_data %>% filter(Time == 6) %>%    
      GO_and_KEGG_gsea(keep.all = TRUE, GO_list = "dros_ortho_GO") %>% 
      mutate(Time = 6, Comparison = "Caste"),
    caste_GO_data %>% filter(Time == 8) %>%    
      GO_and_KEGG_gsea(keep.all = TRUE, GO_list = "dros_ortho_GO") %>% 
      mutate(Time = 8, Comparison = "Caste")
  ) 
  significant <- GO_Dmel_annotations_caste %>% filter(pval < 0.05) %>% pull(pathway) %>% unique()
  GO_Dmel_annotations_caste <- GO_Dmel_annotations_caste %>%
    filter(pathway %in% significant)

  
  # Temporal change, in each caste (A. mel)
  GO_Amel_annotations_temporalQ <- time_GO_data %>%         
    filter(Caste == "Queen") %>%
    group_by(gene) %>%
    summarise(statistic = statistic[which.max(abs(statistic))], .groups = "drop") %>%
    GO_and_KEGG_gsea(keep.all = TRUE, GO_list = "bee_GO") %>% 
    mutate(Time = "Queen", Comparison = "Queen temporal change")
  
  GO_Amel_annotations_temporalW <- time_GO_data %>%          # WHAT THE HELL GOES HERE?
    filter(Caste == "Worker") %>%
    group_by(gene) %>%
    summarise(statistic = statistic[which.max(abs(statistic))], .groups = "drop") %>%
    GO_and_KEGG_gsea(keep.all = TRUE, GO_list = "bee_GO") %>% 
    mutate(Time = "Worker", Comparison = "Worker temporal change")
  
  significant_q <- GO_Amel_annotations_temporalQ %>% filter(pval < 0.05) %>% pull(pathway) %>% unique()
  significant_w <- GO_Amel_annotations_temporalW %>% filter(pval < 0.05) %>% pull(pathway) %>% unique()
  
  GO_Amel_annotations_temporalQ <- GO_Amel_annotations_temporalQ %>%
    filter(pathway %in% unique(c(significant_q, significant_w)))
  GO_Amel_annotations_temporalW <- GO_Amel_annotations_temporalW %>%
    filter(pathway %in% unique(c(significant_q, significant_w)))
  
  # Temporal change, in each caste (D. mel)
  GO_Dmel_annotations_temporalQ <- time_GO_data %>%          # WHAT THE HELL GOES HERE?
    filter(Caste == "Queen") %>%
    group_by(gene) %>%
    summarise(statistic = statistic[which.max(abs(statistic))], .groups = "drop") %>%
    GO_and_KEGG_gsea(keep.all = TRUE, GO_list = "dros_ortho_GO") %>% 
    mutate(Time = "Queen", Comparison = "Queen temporal change")
  
  GO_Dmel_annotations_temporalW <- time_GO_data %>%          # WHAT THE HELL GOES HERE?
    filter(Caste == "Worker") %>%
    group_by(gene) %>%
    summarise(statistic = statistic[which.max(abs(statistic))], .groups = "drop") %>%
    GO_and_KEGG_gsea(keep.all = TRUE, GO_list = "dros_ortho_GO") %>% 
    mutate(Time = "Worker", Comparison = "Queen temporal change")
  
  significant_q <- GO_Dmel_annotations_temporalQ %>% filter(pval < 0.05) %>% pull(pathway) %>% unique()
  significant_w <- GO_Dmel_annotations_temporalW %>% filter(pval < 0.05) %>% pull(pathway) %>% unique()
  
  GO_Dmel_annotations_temporalQ <- GO_Dmel_annotations_temporalQ %>%
    filter(pathway %in% unique(c(significant_q, significant_w)))
  GO_Dmel_annotations_temporalW <- GO_Dmel_annotations_temporalW %>%
    filter(pathway %in% unique(c(significant_q, significant_w)))
  
  list(GO_Amel_annotations_caste = GO_Amel_annotations_caste, 
       GO_Dmel_annotations_caste = GO_Dmel_annotations_caste,
       GO_Amel_annotations_temporalQ = GO_Amel_annotations_temporalQ, 
       GO_Amel_annotations_temporalW = GO_Amel_annotations_temporalW,
       GO_Dmel_annotations_temporalQ = GO_Dmel_annotations_temporalQ, 
       GO_Dmel_annotations_temporalW = GO_Dmel_annotations_temporalW) %>%
    saveRDS(file = "output/expr_gsea_results.rds")
} else GO_KEGG_results <- readRDS(file = "output/expr_gsea_results.rds")

source("code/make_pathway_figure.R")

BP_fig_Amel <- GO_KEGG_results$GO_Amel_annotations_caste %>%
  filter(Test_type == "GO: Biological process") %>%
  make_pathway_figure("", "Hours post-grafting")

MF_fig_Amel <- GO_KEGG_results$GO_Amel_annotations_caste %>%
  filter(Test_type == "GO: Molecular function") %>%
  make_pathway_figure("", "Hours post-grafting")

CC_fig_Amel <- GO_KEGG_results$GO_Amel_annotations_caste %>%
  filter(Test_type == "GO: Cellular component") %>%
  make_pathway_figure("", "Hours post-grafting")

kegg_fig_Amel <- GO_KEGG_results$GO_Amel_annotations_caste %>%
  filter(Test_type == "KEGG") %>%
  make_pathway_figure("", "Hours post-grafting")

BP_fig_Dmel <- GO_KEGG_results$GO_Dmel_annotations_caste %>%
  filter(Test_type == "GO: Biological process") %>%
  make_pathway_figure("", "Hours post-grafting")

MF_fig_Dmel <- GO_KEGG_results$GO_Dmel_annotations_caste %>%
  filter(Test_type == "GO: Molecular function") %>%
  make_pathway_figure("", "Hours post-grafting")

CC_fig_Dmel <- GO_KEGG_results$GO_Dmel_annotations_caste %>%
  filter(Test_type == "GO: Cellular component") %>%
  make_pathway_figure("", "Hours post-grafting")

kegg_fig_Dmel <- GO_KEGG_results$GO_Dmel_annotations_caste %>%
  filter(Test_type == "KEGG") %>%
  make_pathway_figure("", "Hours post-grafting")
```

### GO and KEGG enrichment using _A. mellifera_ annotations {.tabset}

Red means relatively higher expression of the focal pathway/process in queens, blue means higher in workers. Calculated separately for each of the 4 time points. A single asterisk indicates statistically significant enrichment, and a double asterisk indicates that this significant result remained after Benjamini-Hochberg false discovery rate correction (which is overly conservative here, since these multiple tests are not independent).


#### GO: Biological process
```{r enrichBP, fig.height=10, fig.width = 5.3}
BP_fig_Amel
```

#### GO: Molecular function
```{r enrichMF, fig.height=10, fig.width = 5.3}
MF_fig_Amel
```

#### GO: Cellular component
```{r enrichCC, fig.width = 5.3}
CC_fig_Amel
```

#### KEGG
```{r enrichKEGG, fig.height=14, fig.width = 5.3}
kegg_fig_Amel
```

### GO and KEGG enrichment using _D. melanogaster_ annotations {.tabset}

Red means relatively higher expression of the focal pathway/process in queens, blue means higher in workers. Calculated separately for each of the 4 time points. A single asterisk indicates statistically significant enrichment, and a double asterisk indicates that this significant result remained after Benjamini-Hochberg false discovery rate correction (which is overly conservative here, since these multiple tests are not independent).

#### GO: Biological process
```{r enrichBPmel, fig.height=25, fig.width = 5.3}
BP_fig_Dmel
```

#### GO: Molecular function
```{r enrichMFmel, fig.height=25, fig.width = 5.3}
MF_fig_Dmel
```

#### GO: Cellular component
```{r enrichCCmel, fig.height=17, fig.width = 5.3}
CC_fig_Dmel
```

#### KEGG
```{r enrichKEGGmel, fig.height=14, fig.width = 5.3}
kegg_fig_Dmel
```


## Gene coexpression network analysis

### Build the network using `WGCNA::blockwiseModules()`

```{r make_network, results='hide', warning=FALSE, message=FALSE}
if(!file.exists("output/expression_eigengenes.csv")){
  build_network <- function(expression_data){
    
    # We need samples=rows, columns= genes (opposite of limma!)
    my_data <- t(expression_data)
    for(i in ncol(my_data)) my_data[,i] <- as.numeric(my_data[,i])   # needed to convert, from integers, for a WGCNA function to work
    
    # Pick the soft thresholding power that gives a model fit of R^2 > RsquaredCut for the scale-free topology model
    soft_power <- pickSoftThreshold(
      my_data, powerVector = 1:30, RsquaredCut = 0.85, verbose = 5)
    
    print(paste("Network was built using a soft thresholding power of", soft_power$powerEstimate))
    
    cor <- WGCNA::cor
    
    # Use this power to generate a gene co-expression network
    # Largely uses the default arguments, except as stated:
    blockwiseModules(
      my_data, 
      power = soft_power$powerEstimate,
      networkType = "signed",
      minModuleSize = 30,
      verbose = 0,
      saveTOMs = FALSE)
  }
  
  
  # By default, WGCNA gives the transcriptional modules arbitrary names like 'turqoise' or 'darkred'. 
  # I think it's more sensible to name the biggest module as 'Module 1', the second biggest as 'Module 2', etc
  # I use the label 'Module 0' for genes that were not assigned to a module (usually labelled 'grey' by WGCNA)
  convert_colors_to_numbers <- function(network){
    module_sizes <- table(network$colors) %>% sort() %>% rev()
    module_sizes <- c(module_sizes[names(module_sizes) == "grey"], 
                      module_sizes[names(module_sizes) != "grey"])
    module_mappings <- data.frame(
      color = names(module_sizes), 
      new_name = paste("Module", 
                       0:(length(module_sizes)-1)), stringsAsFactors = F)
    
    # Edit the colours of each gene to module names
    network$colors <- module_mappings$new_name[
      match(network$colors, module_mappings$color)]
    network$colors <- factor(network$colors, module_mappings$new_name)
    # Edit the corresponding module eigengenes
    names(network$MEs) <- module_mappings$new_name[
      match(gsub("ME", "", names(network$MEs)), module_mappings$color)]
    network$MEs <- network$MEs %>% dplyr::select(!! module_mappings$new_name)
    network
  }
  
  # Rearrange the data in a handy format for stats and plotting
  rearrange_eigengene_data <- function(network, sample_ids){
    n_modules <- ncol(network$MEs)
    
    sample_ids$sample <- gsub("queen", "q", sample_ids$sample)
    sample_ids$sample <- gsub("worker", "w", sample_ids$sample)
    
    firstup <- function(x) {
      substr(x, 1, 1) <- toupper(substr(x, 1, 1))
      x}
    
    network$MEs %>% 
      rownames_to_column("sample") %>%
      left_join(sample_ids, by = "sample") %>%
      gather(Module, Eigengene, starts_with("Module")) %>%
      mutate(Module = factor(Module,
                             levels = paste("Module", 0:(n_modules - 1)))) %>%
      rename_all(~ firstup(.x)) %>%
      dplyr::rename(Time = Time_point) %>%
      arrange(Module, Caste, Time) %>% as_tibble()
  }
  
  network <- expression_data %>%
    build_network() %>% 
    convert_colors_to_numbers()
  
  expr_eigengenes <- network %>% 
    rearrange_eigengene_data(sample_ids = sample_ids)
  
  connectivity <- data.frame(
    Gene = rownames(expression_data),
    intramodularConnectivity.fromExpr(
      t(expression_data), 
      network$colors, 
      networkType = "signed", 
      scaleByMax = FALSE,
      ignoreColors = "Module 0",
      getWholeNetworkConnectivity = TRUE))
  
  # Merge module memberships with the differentiatial expression results & save
  caste_results <- caste_results %>%
    left_join(tibble(gene = rownames(expression_data), module = network$colors),
              by = c(`Gene symbol` = "gene"))
  time_results <- time_results %>%
    left_join(tibble(gene = rownames(expression_data), module = network$colors),
              by = c(`Gene symbol` = "gene"))
  
  write_csv(connectivity, path = "output/gene_connectivity.csv")
  write_csv(caste_results, path = "output/caste_results.csv")
  write_csv(time_results, path = "output/time_results.csv")
  write_csv(expr_eigengenes, path = "output/expression_eigengenes.csv")
  saveRDS(network, file = "output/expression_network.rds")
} else {
  expr_eigengenes <- read_csv("output/expression_eigengenes.csv")
  network <- readRDS("output/expression_network.rds")
}
```

### Count the number of genes per module
```{r echo=FALSE}
num_modules <- length(unique(network$colors))
```

The algorithm in WGCNA has grouped the `r length(network$colors)` transcripts into `r num_modules` modules of variable size. Note that Module 0 contains all the transcripts that were not assigned to a module (indicating that their expression did not covary detectably with other genes).
```{r}
network$colors %>% table() %>% pander()
```


### Plot correlations between module eigengenes
Note that some modules show correlated expression with other modules, forming 'meta-modules'. Moreover, we can see that certain modules appear to distinguish queens at later times (e.g. 6h and 8h) from workers, or early-stage queens.

```{r fig.height=9}
brms_data <- expr_eigengenes %>%
  mutate(sample = rep(colnames(expression_data), length(unique(Module)))) %>%
  spread(Module, Eigengene) %>%
  rename_at(vars(starts_with("Module")), ~ gsub("Module ", "m", .x)) %>%
  mutate(Time = as.numeric(as.character(Time)),
         Caste = factor(Caste, c("Queen", "Worker"))) %>%
  mutate(scaled_Time = as.numeric(scale(Time))) %>%
  mutate_at(vars(starts_with("m")), ~ as.numeric(scale(.x))) %>%
  mutate(Replicate = C(factor(Replicate), contr = "contr.sum")) 




mat <- dplyr::select(brms_data, starts_with("m")) %>% 
  rename_all(~ str_replace_all(.x, "m", "Module ")) %>%
  as.matrix()
rownames(mat) <- paste(brms_data$Caste, brms_data$Time, brms_data$Replicate)

paletteLength <- 50
myColor <- colorRampPalette(c(brewer.pal(9, "Blues")[6], "white", brewer.pal(9, "Reds")[6]))(paletteLength)
myBreaks <- c(seq(min(mat, na.rm=T), 0, length.out=ceiling(paletteLength/2) + 1), 
              seq(max(mat, na.rm=T)/paletteLength, max(mat, na.rm=T), length.out=floor(paletteLength/2)))

pheatmap(mat, color = myColor, breaks = myBreaks,
         cutree_rows = 5, cutree_cols = 5)
```





### Fit Bayesian model to the eigengene estimates

The following code chunk fits a Bayesian model to the eigenegene estimates produced by `WGCNA`. The 'eigengene' for sample $i$, module $j$, gives a measure of the expression level of all the coexpressed genes that were assigned to module $j$, for sample $i$ relative to other samples. The eigengenes were transformed to have a mean of zero and standard deviation of 1 prior to analysis. 

Because the module eigengenes are somewhat correlated with each other, it is valuable to run a single model of all $j$ module eigengenes (thereby using the information in this correlation), rather than running $j$ univariate models. We therefore ran a single multivariate model encompassing all `r num_modules` modules (including module zero, the unassigned genes).  

Furthermore, we expected a prior that some eigengenes will change non-linearly, for example increasing to a plateau, or increasing then decreasing again, throughout the course of development. We therefore fit the time effect using a thin plate regression line smooth (i.e. we used a generalised additive model) with basis dimension k=4, to allow for a non-linear time effect. To allow for a caste-specific change over time, we fit one smooth for the reference caste (queens), and fit a 'difference smooth' for the other caste to allow it to deviate.

Finally, our experiment was split into 4 replicates/blocks, and so we fit replicate as a random effect to account for similarity in eigengenes between samples measured in the same block, and prevent pseuodreplication.

In `brms` notations (which is similar to e.g. `lme4` and many other R packages), the model formula for each module is written as

$$ y \sim Caste + s(Time, by = Caste, k = 4) + Replicate$$

where $y$ is the eigengene for module $j$. 

```{r}
# Define the model formula for all the j modules
j <- length(unique(expr_eigengenes$Module))
brms_formula <- bf(
  paste("mvbind(",
        paste0(paste("m", 0:(j - 1), 
                     sep = ""), collapse = ","),
        ") ~ Caste + s(Time, by = Caste, k = 4) + Replicate", sep = "") 
) + set_rescor(FALSE)   

mod_levels <- paste("m", 0:(j - 1), sep = "")

brms_data$Sample[str_detect(brms_data$Sample, "t0")] <- paste("t0", brms_data$Replicate[str_detect(brms_data$Sample, "t0")], sep ="")

brms_data <- list(
  brms_data %>% 
    mutate(Caste = replace(Caste, Sample %in% c("t0A", "t0B"), "Queen"),
           Caste = replace(Caste, Sample %in% c("t0C", "t0D"), "Worker")),
  brms_data %>% 
    mutate(Caste = replace(Caste, Sample %in% c("t0A", "t0C"), "Queen"),
           Caste = replace(Caste, Sample %in% c("t0B", "t0D"), "Worker")),
  brms_data %>% 
    mutate(Caste = replace(Caste, Sample %in% c("t0A", "t0D"), "Queen"),
           Caste = replace(Caste, Sample %in% c("t0B", "t0C"), "Worker")), 
  brms_data %>% 
    mutate(Caste = replace(Caste, Sample %in% c("t0B", "t0C"), "Queen"),
           Caste = replace(Caste, Sample %in% c("t0A", "t0D"), "Worker")), 
  brms_data %>% 
    mutate(Caste = replace(Caste, Sample %in% c("t0B", "t0D"), "Queen"),
           Caste = replace(Caste, Sample %in% c("t0A", "t0C"), "Worker")), 
  brms_data %>% 
    mutate(Caste = replace(Caste, Sample %in% c("t0C", "t0D"), "Queen"),
           Caste = replace(Caste, Sample %in% c("t0A", "t0B"), "Worker"))) %>%
  map(~.x %>% rename_all(~ str_replace_all(.x, "Module ", "m")))


run_brms_eigengene_model <- function() {
  brm_multiple(
    brms_formula,
    data = brms_data,
    prior = c(set_prior("normal(0, 5)", class = "b", resp = "m0"),
              set_prior("normal(0, 5)", class = "b", resp = "m1"),
              set_prior("normal(0, 5)", class = "b", resp = "m2"),
              set_prior("normal(0, 5)", class = "b", resp = "m3"),
              set_prior("normal(0, 5)", class = "b", resp = "m4"),
              set_prior("normal(0, 5)", class = "b", resp = "m5"),
              set_prior("normal(0, 5)", class = "b", resp = "m6"),
              set_prior("normal(0, 5)", class = "b", resp = "m7"),
              set_prior("normal(0, 5)", class = "b", resp = "m8"),
              set_prior("normal(0, 5)", class = "b", resp = "m9"),
              set_prior("normal(0, 5)", class = "b", resp = "m10"),
              set_prior("normal(0, 5)", class = "b", resp = "m11"),
              set_prior("normal(0, 5)", class = "b", resp = "m12"),
              set_prior("normal(0, 5)", class = "b", resp = "m13"),
              set_prior("normal(0, 5)", class = "b", resp = "m14"),
              set_prior("normal(0, 5)", class = "b", resp = "m15"),
              set_prior("normal(0, 5)", class = "b", resp = "m16"),
              set_prior("normal(0, 5)", class = "b", resp = "m17"),
              set_prior("normal(0, 5)", class = "b", resp = "m18")), 
    chains = 4, iter = 4000, cores = 1, inits = 0,
    control = list(adapt_delta = 0.9999, max_treedepth = 20))
}

if(!file.exists("output/brms_eigengene_model_expression.rds")){
  brms_eigengene_model <- run_brms_eigengene_model()
  saveRDS(brms_eigengene_model, "output/brms_eigengene_model_expression.rds")
} else brms_eigengene_model <- readRDS("output/brms_eigengene_model_expression.rds")
```





<!-- ```{r} -->
<!-- # OG version: -->
<!-- eigengenes <- read_csv("output/expression_eigengenes.csv") # can delete after testing -->

<!-- # Define the model formula for all the j modules -->
<!-- j <- length(unique(eigengenes$Module)) -->
<!-- brms_formula <- bf( -->
<!--   paste("mvbind(", -->
<!--         paste0(paste("m", 0:(j - 1),  -->
<!--                      sep = ""), collapse = ","), -->
<!--         ") ~ Caste + s(Time, by = Caste, k = 4) + Replicate", sep = "")  -->
<!-- ) + set_rescor(FALSE)    -->

<!-- mod_levels <- paste("Module", 0:(j - 1)) -->

<!-- eigengenes$Time <- as.numeric(as.character(eigengenes$Time)) -->

<!-- brms_data <- eigengenes %>% -->
<!--   dplyr::select(Caste, Time, Replicate, Module, Eigengene) %>% -->
<!--   spread(Module, Eigengene) %>% -->
<!--   rename_all(~ str_replace_all(.x, "Module ", "m")) %>% -->
<!--   mutate(across(starts_with("m"), ~ as.numeric(scale(.x)))) # scale the eigengenes -->

<!-- t0_indexes <- which(brms_data$Caste == "Time zero") -->


<!-- v1 <- brms_data$Caste; v2 <- brms_data$Caste; v3 <- brms_data$Caste -->
<!-- v4 <- brms_data$Caste; v5 <- brms_data$Caste; v6 <- brms_data$Caste -->
<!-- v1[t0_indexes] <- c("Queen", "Queen", "Worker", "Worker") -->
<!-- v2[t0_indexes] <- c("Queen", "Worker", "Queen", "Worker") -->
<!-- v3[t0_indexes] <- c("Queen", "Worker", "Worker", "Queen") -->
<!-- v4[t0_indexes] <- c("Worker", "Queen", "Queen", "Worker") -->
<!-- v5[t0_indexes] <- c("Worker", "Queen", "Worker", "Queen") -->
<!-- v6[t0_indexes] <- c("Worker", "Worker", "Queen", "Queen") -->
<!-- data_permutations <- list( -->
<!--   brms_data %>% mutate(Caste = v1), -->
<!--   brms_data %>% mutate(Caste = v2), -->
<!--   brms_data %>% mutate(Caste = v3), -->
<!--   brms_data %>% mutate(Caste = v4), -->
<!--   brms_data %>% mutate(Caste = v5), -->
<!--   brms_data %>% mutate(Caste = v6)) -->


<!-- # run one model on each relabelled version of the data  -->
<!-- brms_eigengene_model <- brm_multiple( -->
<!--   brms_formula,  -->
<!--   iter = 4000, chains = 1,  -->
<!--   prior = prior(normal(0, 5), class = "b"),  -->
<!--   data = data_permutations) -->
<!-- ``` -->


<!-- ```{r eigen_model, results='hide', warning=FALSE, message=FALSE} -->
<!-- # Define the model formula for all the j modules -->
<!-- j <- length(unique(eigengenes$Module)) -->
<!-- brms_formula <- bf( -->
<!--   paste("mvbind(", -->
<!--         paste0(paste("m", 0:(j - 1),  -->
<!--                      sep = ""), collapse = ","), -->
<!--         ") ~ Time + Caste + Time:Caste + I(Time^2) + I(Time^2):Caste + Replicate", sep = "") # Caste + s(Time, by = Caste, k = 4) + (1 | Replicate) -->
<!-- ) + set_rescor(FALSE)    -->

<!-- mod_levels <- paste("Module", 0:(j - 1)) -->



<!-- run_brms_eigengene_model <- function() { -->
<!--   brm( -->
<!--     brms_formula, -->
<!--     data = brms_data, -->
<!--     prior = c(set_prior("normal(0, 3)", class = "b")),  -->
<!--     chains = 1, iter = 4000, cores = 1, inits = 0, -->
<!--     control = list(adapt_delta = 0.9999, max_treedepth = 20)) -->
<!-- } -->

<!-- if(!file.exists("output/brms_eigengene_model_expression.rds")){ -->

<!--   brms_eigengene_model_chain1 <- run_brms_eigengene_model() -->
<!--   brms_eigengene_model_chain2 <- run_brms_eigengene_model() -->
<!--   brms_eigengene_model_chain3 <- run_brms_eigengene_model() -->
<!--   brms_eigengene_model_chain4 <- run_brms_eigengene_model() -->
<!--   brms_eigengene_model <- combine_models(brms_eigengene_model_chain1, brms_eigengene_model_chain2, -->
<!--                                        brms_eigengene_model_chain3, brms_eigengene_model_chain4) -->
<!--   saveRDS(brms_eigengene_model, "output/brms_eigengene_model_expression.rds") -->
<!-- } else brms_eigengene_model <- readRDS("output/brms_eigengene_model_expression.rds") -->
<!-- ``` -->

### Make Figure X

Plot the model-estimated means for the module expression levels ('eigengenes').

```{r eigen_plot, fig.width=10, fig.height=10, fig.showtext=TRUE, warning=F, message=F}
module_levels <- paste("Module", 0:(length(mod_levels) - 1))

# Data for the raw data point in figure
raw_data <- brms_data[[1]] %>%
  gather(Module, eigengene, starts_with("m")) %>%
  mutate(Module = str_replace_all(Module, "m", "Module "),
         Module = factor(Module, module_levels)) %>%
    mutate(Caste = replace(Caste, Time == 0, NA))


# Define y limits for the figure: 3% either side of the full range of the raw data
ylimits <- c(min(raw_data$eigengene), max(raw_data$eigengene))
range_frac <- 0.03 * (ylimits[2] - ylimits[1])
ylimits <- c(ylimits[1] - range_frac,
             ylimits[2] + range_frac * 1.1) # add a little extra space for gene counts

# Define new data to get the lines and predicted means 
new <- expand_grid(
  Time = seq(0, 8, by = 0.25), 
  Replicate = c("A", "B", "C", "D"),
  Caste = c("Queen", "Worker")) %>%
  mutate(para = paste("V", 1:n(), sep = "")) 

# Function to get all the predictions for each module
make_preds <- function(){
  preds <- fitted(brms_eigengene_model, new, summary = FALSE, re_formula = NA, nsamples = 5000) 
  
  map_df(1:length(unique(network$colors)), ~ {
    as.data.frame(preds[,, .x]) %>% 
      mutate(draw = 1:n(),
             Module = paste("Module", .x - 1)) %>% 
      gather(para, eigengene, -draw, -Module)}) %>% 
    left_join(new, by="para") %>% 
    as_tibble() %>%
    mutate(Module = factor(Module, module_levels)) %>%
    group_by(Module, Time, Caste, draw) %>% # average over replicates
    summarise(eigengene = mean(eigengene)) %>%
    mutate(Caste = replace(Caste, Time == 0, NA)) %>%
    distinct()
}
preds <- make_preds()

 
# Calculate the median and Est.Error of the posterior at 0h, 2h, 4h, 6h and 8h in each caste
means_data <- preds %>%
  filter(Time %in% c(0,2,4,6,8)) %>%
  group_by(Module, Caste, Time) %>%
  summarise(stats = list(as.data.frame(posterior_summary(eigengene))),
            .groups = "drop") %>%
  ungroup() %>% unnest(stats) %>% dplyr::rename(eigengene = Estimate)

# Find the posterior estimate of the median fit line
mean_line_data <- preds %>%
  group_by(Module, Caste, Time) %>%
  summarise(stats = list(as.data.frame(posterior_summary(eigengene)))) %>%
  ungroup() %>% unnest(stats) %>% dplyr::rename(eigengene = Estimate)


gene_number_labels <- dplyr::rename(network$colors %>% table() %>% 
  broom::tidy(), Module = `.`) %>%
  mutate(label_text = paste(n, "genes"),
         Time = 8.21, eigengene = 3.5,
         Module = factor(Module, module_levels))

# Make the figure
pd <- position_dodge(0.35)

set.seed(1)
eigen_plot <- preds %>%
  filter(draw %in% sample(max(preds$draw), 100)) %>% # plot random 100 posterior fit lines
  ggplot(aes(Time, eigengene)) +
  scale_fill_manual(values = c(queen_colour, worker_colour, "white"), 
                    aesthetics = c("colour", "fill"), name = "Cell type") +  
  
  geom_line(alpha = 0.05, size = 0.4,
            aes(colour = Caste, group = paste(draw, Caste))) +
  # Add the median best fit line
  geom_line(data = mean_line_data, size = 0.6, alpha = 0.7,
            aes(colour = Caste, group = Caste)) +
  # Add the raw data points
  geom_point(data = raw_data, aes(fill = Caste),
             size = 0.8, pch = 21, colour = "black", stroke = 0.3, position = pd) + 
  # Add the posterior median +/- error bars
  geom_errorbar(data = means_data, 
                width = 0, colour = "grey20",
                aes(ymin = eigengene - Est.Error, group = Caste,
                    ymax = eigengene + Est.Error), position = pd) +
  geom_point(data = means_data, aes(fill = Caste), 
             pch = 21, size = 2, alpha = 0.7, position = pd) +
  
  geom_text(data = gene_number_labels, aes(label = label_text), 
            size = 2.8, hjust = 1, colour = "grey20", family = nice_font) + 
  facet_wrap(~ Module) + 
  ylab("Relative expression of genes in this module\n(eigengene, posterior estimates)") +
  xlab("Hours post-grafting into queen or worker cell") + 
  
  coord_cartesian(ylim = c(-3.6, 3.6)) +
  theme_bw() + 
  theme(legend.position = "top",
        text = element_text(family = nice_font),
        strip.background = element_rect(fill = "white", colour = "white"))

ggsave(eigen_plot, filename = "figures/eigengenes_expression_network.pdf", width = 8, height = 8)
eigen_plot
```

### Calculate effect sizes for the module eigengenes

**Table SX:** The table shows a summary of the posterior estimate of the difference in mean module eigengenes between queen- and worker-destined larvae at each of the four time points. The estimates are derived from the posterior estimates for a Bayesian multivariate generalised additive mixed model where the response variable for each sample was a length-`r num_modules` vector of eigengenes for the `r num_modules` modules. The model allowed for caste-specific, non-linear changes in module eigengenes over time (see Figure XXX), and fit "Replicate" as a random intercept. The eigengenes were mean-centred and scaled to unit variance, so the units in the 'Caste difference' column can be interpreted as the standardised effect size (Cohen's $d$). Other columns show the mean deviation of data points from the estimated mean, the 95% credible interval for the mean, and the posterior probability that the true effect size has the opposite sign to the first column (similar to a one-tailed $p$-value).

```{r}
my_summary <- function(x) {

    p <- 1 - (as.numeric(bayestestR::p_direction(x)))
    posterior_summary(x) %>% as_tibble() %>%
      mutate(PP = p) %>%
      mutate(` ` = ifelse(PP < 0.1, "~", ""),
             ` ` = replace(` `, PP < 0.05, "\\*"),
             ` ` = replace(` `, PP < 0.01, "**"),
             ` ` = replace(` `, PP < 0.001, "***"),
             ` ` = replace(` `, PP == " ", "")) %>%
      mutate(PP = as.character(round(PP, 4)))
}

preds %>%
  filter(Time %in% c(2,4,6,8)) %>%
  group_by(Time, Module, draw) %>%
  summarise(Caste_difference = eigengene[1] - eigengene[2]) %>% # Q - W
  group_by(Module, Time) %>%
  summarise(stats = list(my_summary(Caste_difference)), .groups = "drop") %>%
  ungroup() %>% unnest(stats) %>% dplyr::rename(Caste_difference = Estimate) %>%
  dplyr::select(-Module) %>%
  kable(digits = 3) %>%
  kable_styling(full_width = FALSE) %>%
  pack_rows("Module 0", 1, 4) %>%
  pack_rows("Module 1", 5, 8)  %>%
  pack_rows("Module 2", 9, 12)  %>%
  pack_rows("Module 3", 13, 16)  %>%
  pack_rows("Module 4", 17, 20)  %>%
  pack_rows("Module 5", 21, 24)  %>%
  pack_rows("Module 6", 25, 28)  %>%
  pack_rows("Module 7", 29, 32)  %>%
  pack_rows("Module 8", 33, 36)  %>%
  pack_rows("Module 9", 37, 40)  %>%
  pack_rows("Module 10", 41, 44)  %>%
  pack_rows("Module 11", 45, 48)  %>%
  pack_rows("Module 12", 49, 52)  %>%
  pack_rows("Module 13", 53, 56)  %>%
  pack_rows("Module 14", 57, 60)  %>%
  pack_rows("Module 15", 61, 64)  %>%
  pack_rows("Module 16", 65, 68)  %>%
  pack_rows("Module 17", 69, 72)  %>%
  pack_rows("Module 18", 73, 76) %>%
  scroll_box(height = "300px")
```



### Identify GO and KEGG terms enriched in each module

```{r GO.and.KEGG.hypergeometric, results = 'hide', warning=FALSE, message=FALSE}
# Code up a hypergeometric test
manual_GO_enrich <- function(
  GO_ID,
  number_genes_in_set_with_focal_GO,
  number_genes_in_universe_with_focal_GO,
  number_genes_in_set,
  number_genes_in_universe){
  
  p <- phyper(
    q = number_genes_in_set_with_focal_GO - 1, 
    m = number_genes_in_universe_with_focal_GO, 
    n = number_genes_in_universe - number_genes_in_universe_with_focal_GO, 
    k = number_genes_in_set, 
    
    lower.tail = FALSE, log.p = FALSE)
  
  prop_in_set  <- number_genes_in_set_with_focal_GO / number_genes_in_set
  prop_in_univ <- number_genes_in_universe_with_focal_GO / number_genes_in_universe
  
  # Log odds ratio: odds that the focal GO is in the set / odds it's in the universe
  enrichment_LOR <- (prop_in_set / (1 - prop_in_set)) /
    (prop_in_univ / (1 - prop_in_univ))
  
  tibble(
    ID = GO_ID,
    GeneRatio = paste(number_genes_in_set_with_focal_GO, 
                      number_genes_in_set, sep="/"), 
    BgRatio = paste(number_genes_in_universe_with_focal_GO, 
                    number_genes_in_universe, sep="/"),
    enrichment_LOR,
    pvalue = p
  )
}


genes_in_module <- function(module_number){
  rownames(expression_data)[network$colors == paste("Module", module_number)] 
}



GO_and_KEGG_hypergeometric <- function(
  gene_set, gene_universe, 
  gene_set_entrez, gene_universe_entrez,
  apis.db, GO_list, 
  min_size, keep_all){
  
  p <- 0.05; if(keep_all) p <- 1
  neatness <- function(x) format(round(x, 4), nsmall = 4) # for rounding
  
  # Define internal GO enrichment function (custom, but testing shows gives identical results as clusterProfiler)
  # However, it works without an Org.db, which we needed due to there being no publicly-available 
  # GO annotations for many of our genes (we supplemented using BLAST2GO)
  GO_enrichment <- function(gene_set,
                            gene_universe,
                            min_size,
                            keep_all){

    # get GO annotations for genes in the focal set/module
    gene_set <- tbl(db, GO_list) %>%
      left_join(tbl(db, "gene_names"), 
                by = c("SYMBOL" = "gene_symbol")) %>%
      dplyr::rename(gene = SYMBOL) %>%
      dplyr::select(gene, GO, gene_name) %>%
      filter(gene %in% gene_set) %>%
      collect(n=Inf) %>%
      distinct() # should already be, add this to double check
    
    #  do the same for the gene universe
    gene_universe <- tbl(db, GO_list) %>%
      left_join(tbl(db, "gene_names"), 
                by = c("SYMBOL" = "gene_symbol")) %>%
      dplyr::rename(gene = SYMBOL) %>%
      dplyr::select(gene, GO, gene_name) %>%
      filter(gene %in% gene_universe) %>%
      collect(n=Inf) %>%
      distinct() # should already be, add this to double check
    
    unique_GOs <- unique(gene_set$GO)
    n_unique_GOs_in_set <- length(unique_GOs)
    module_size <- nrow(gene_set)
    universe_size <- nrow(gene_universe)
    
    output <- map_df(1:n_unique_GOs_in_set, function(i){
      focal_GO <- unique_GOs[i]
      
      x1 <- gene_set %>% filter(GO == focal_GO) %>% nrow()
      if(x1 < min_size) return(NULL)
      x2 <- gene_universe %>% filter(GO == focal_GO) %>% nrow()
      
      manual_GO_enrich(
        GO_ID = focal_GO,
        number_genes_in_set_with_focal_GO = x1,
        number_genes_in_universe_with_focal_GO = x2,
        number_genes_in_set = module_size,
        number_genes_in_universe = universe_size
      )
    }) 
    
    if(!keep_all & nrow(output) > 0) output <- output %>% filter(pvalue < 0.05)
    if(nrow(output)==0) return(NULL)
    
    output %>%
      left_join(tbl(db, "go_meanings") %>% collect(),
                by = c("ID" = "GO")) %>%
      dplyr::rename(Ontology = ontology,
                    Meaning = term) %>%
      dplyr::select(Ontology, ID, Meaning, everything()) %>%
      distinct()
  }
  
  # Define internal KEGG enrichment function (uses clusterProfiler)
  kegg_enrichment <- function(gene_set, gene_universe, 
                              GO_list, min_size, keep_all){
    
    if(GO_list == "dros_ortho_GO"){
      
      gene_set_CG_drosophila <- tibble(SYMBOL = gene_set) %>%
        left_join(tbl(db, "dros_ortho_GO") %>% 
                    dplyr::select(FLYBASECG, SYMBOL) %>% collect(n=Inf),
                  by = "SYMBOL") %>%
        filter(!is.na(FLYBASECG)) %>%
        pull(FLYBASECG) %>% unique()
      
      gene_universe_CG_drosophila <- tibble(SYMBOL = gene_universe) %>%
        left_join(tbl(db, "dros_ortho_GO") %>% 
                    dplyr::select(FLYBASECG, SYMBOL) %>% collect(n=Inf),
                  by = "SYMBOL") %>%
        filter(!is.na(FLYBASECG)) %>%
        pull(FLYBASECG) %>% unique()
      
      gene_set_CG_drosophila <- paste("Dmel_", gene_set_CG_drosophila, sep = "")
      gene_universe_CG_drosophila <- paste("Dmel_", gene_universe_CG_drosophila, sep = "")
      
      result <-  clusterProfiler::enrichKEGG(
        gene = gene_set_CG_drosophila, organism = "dme", keyType = "kegg", pvalueCutoff = p,
        universe = gene_universe_CG_drosophila, minGSSize = min_size, maxGSSize = 500,
        qvalueCutoff = 1, use_internal_data = FALSE, pAdjustMethod = "BH")
    }
    else {
      result <-  clusterProfiler::enrichKEGG(
        gene = gene_set_entrez, organism = "ame", keyType = "kegg", pvalueCutoff = p,
        universe = gene_universe_entrez, minGSSize = min_size, maxGSSize = 500,
        qvalueCutoff = 1, use_internal_data = FALSE, pAdjustMethod = "BH")
    }
    
    if(is.null(result)) return(NULL)
    
    result <- result@result
    is_enriched <- sapply(result$GeneRatio, 
                          function(x) eval(parse(text=x))) > 
      sapply(result$BgRatio, 
             function(x) eval(parse(text=x)))
    result <- result[is_enriched, ] %>% mutate(p.adjust = p.adjust(pvalue, method = "BH"))
    
    if(nrow(result %>% filter(pvalue < p)) == 0) return(NULL)
    if(!keep_all) result <- result %>% filter(pvalue < 0.05)
    
    data.frame(Ontology = "KEGG", result, stringsAsFactors = FALSE)
  }
  
  kegg_result <- kegg_enrichment(gene_set, gene_universe, GO_list, min_size, keep_all) 
  
  if(!is.null(kegg_result)){
    kegg_result <- kegg_result %>%
      dplyr::rename(Meaning = Description) %>%
      mutate(
        prop_in_set  = sapply(lapply(strsplit(GeneRatio, split = "/"), as.numeric), 
                              function(x) (x[1]) / x[2]),
        prop_in_univ = sapply(lapply(strsplit(BgRatio, split = "/"), as.numeric), 
                              function(x) x[1] / x[2]),
        enrichment_LOR = (prop_in_set / (1 - prop_in_set)) / (prop_in_univ / (1 - prop_in_univ))) %>%
      dplyr::select(Ontology, ID, Meaning, GeneRatio, BgRatio, enrichment_LOR, pvalue) 
  }
  
  kegg_result %>%
    bind_rows(GO_enrichment(gene_set, gene_universe, min_size, keep_all))
}

make_module_GO_table <- function(
  eigengenes, GO_list,
  min_size = 5, keep_all = FALSE){

  n_modules <- eigengenes$Module %>% unique() %>% length()
  module_vec <- 0:(n_modules-1)
  
  add_name_col <- function(df){
    df$gene_names <- map_chr(
      df$geneID, 
      ~ paste0(converter$gene_name[match(.x, converter$entrez_id)], 
               collapse = "; "))
    df %>% mutate(geneID = map_chr(geneID, function(x) paste0(x, collapse = " ")))
  }
  
  converter <- tbl(db, "gene_names") %>% collect(n=Inf) %>%
    filter(gene_symbol %in% rownames(expression_data))
  
  hub <- AnnotationHub::AnnotationHub()
  select <- dplyr::select # wish this worked :(
  rename <- dplyr::rename
  filter <- dplyr::filter
  apis.db <- hub[["AH81619"]]
  
  gene_universe <- rownames(expression_data)
  
  gene_universe_entrez <- converter$entrez_id[
    converter$gene_symbol %in% gene_universe] %>% 
    as.character() 
  
  map_df(module_vec, function(i) { 
    
    print(paste("Doing", i, "/", n_modules, "modules"))
    
    # Entrez IDs of the genes in the focal module
    gene_set <- genes_in_module(i)
    gene_set_entrez <- converter$entrez_id[
      converter$gene_symbol %in% gene_set] %>% 
      as.character()
    
    GO_and_KEGG_hypergeometric(
      gene_set = gene_set, 
      gene_universe = gene_universe, 
      gene_set_entrez = gene_set_entrez, 
      gene_universe_entrez = gene_universe_entrez,
      apis.db = apis.db,
      GO_list = GO_list,
      min_size = min_size,
      keep_all = keep_all) %>% 
      as_tibble() %>% 
      mutate(Module = paste("Module", i)) %>%
      dplyr::select(Module, everything())}) %>%
      mutate(Ontology = replace(Ontology, Ontology == "BP", "GO: BP"),
             Ontology = replace(Ontology, Ontology == "MF", "GO: MF"),
             Ontology = replace(Ontology, Ontology == "CC", "GO: CC"))
}





module_enrichment_plot <- function(df, is.KEGG = FALSE){
  label <- "Name of GO term"
  if(is.KEGG) label <- "Name of KEGG term"
  df %>% 
    arrange(Module, enrichment_LOR) %>% 
    mutate(Meaning = factor(Meaning, unique(Meaning)),
           Ontology = factor(
             Ontology, c("GO: Biological process", 
                          "GO: Molecular function", 
                          "GO: Cellular component", "KEGG"))) %>%
    ggplot(aes(Meaning, enrichment_LOR)) + 
    geom_bar(stat = "identity", colour = "grey10", fill = "#0CE3AC") + # aes(fill = sig), 
    facet_wrap(~Module) + 
    scale_fill_brewer(palette = "Accent", direction = -1) + 
    scale_x_discrete(labels = function(x) str_wrap(x, width = 60)) +
    theme_bw() +
    theme(legend.position = "none", 
          strip.background = element_blank(), 
          strip.text = element_text(size = 10)) + 
    ylab("Enrichment (log odds ratio)") + xlab(label) + 
    coord_flip() 
}  

module_GO_table_amel <- make_module_GO_table(expr_eigengenes, GO_list = "bee_GO") 
module_GO_table_dmel <- make_module_GO_table(expr_eigengenes, GO_list = "dros_ortho_GO")  
```


### Tables of the module enrichment results {.tabset}

Click the buttons to view or export these results.

#### Using _A. mellifera_ annotations

```{r}
present_module_GO_table <- function(module_GO_tbl){
  
  focal <- module_GO_tbl %>%
    arrange(Module, Ontology, pvalue) %>%
    # filter(Module == paste("Module", module) & pvalue < 0.05)  %>%
    filter(pvalue < 0.05)  %>%
    mutate(`Gene & Background ratios` = paste(GeneRatio, BgRatio),
           ID = paste(Meaning, " (", ID, ")", sep = "")) %>%
    dplyr::rename(Enrichment = enrichment_LOR) %>%
    dplyr::select(-GeneRatio, -BgRatio, -Meaning) %>%
    dplyr::select(Ontology, ID, `Gene & Background ratios`, everything())
  
  # bp_rows <- which(focal$Ontology == "GO: Biological process")
  # mf_rows <- which(focal$Ontology == "GO: Molecular function")
  # cc_rows <- which(focal$Ontology == "GO: Cellular component")
  # kg_rows <- which(focal$Ontology == "KEGG")
  
  focal %>%
   # dplyr::select(-Module) %>%
    dplyr::select(Module, everything()) %>%
    mutate_if(is.numeric, ~ round(.x, 3)) %>%
    datatable(rownames = FALSE, filter = 'top', fillContainer = TRUE,
              extensions = 'Buttons', options = list(
                dom = 'Bfrtip', pageLength = 10,
                buttons = c('copy', 'csv', 'excel', 'pdf')))
}
present_module_GO_table(module_GO_table_amel) 
```


#### Using _D. melanogaster_ annotations

```{r}
present_module_GO_table(module_GO_table_dmel) 
```



<!-- ### Figures of the module enrichment results {.tabset} -->

<!-- Showing a few of the most caste-biased modules, based on inspection of the eigengenes figure and statistical table. -->

<!-- #### KEGG -->
<!-- ```{r module_enrich1, fig.height = 8, fig.width=9, message=FALSE, warning=FALSE, results='hide'} -->
<!-- #mods <- module_GO_table_dmel$Module -->
<!-- mods <- c("Module 6", "Module 7", "Module 12", "Module 15", "Module 17") -->
<!-- module_KEGG <- module_GO_table_dmel %>%  -->
<!--   filter(Ontology == "KEGG", Module %in% mods) %>%  -->
<!--   module_enrichment_plot(is.KEGG = TRUE) -->
<!-- #ggsave(module_KEGG, file = "figures/Figure 4 - module KEGG.pdf", height = 7, width = 8) -->
<!-- module_KEGG -->
<!-- ``` -->
<!-- <br></br> -->
<!-- **Figure 4**: Results of KEGG pathway enrichment analysis for the genes in each of the three significantly pheromone-sensitive transcriptional modules. The gene universe was defined as all genes for which we found an ortholog in all four species (i.e. the set that was used to discover these co-expressed modules). All KEGG terms shown in green were significantly enriched (p < 0.05), and those shown in purple remained significant after correction for multiple testing. Fold enrichment was calculated as the proportion of genes associated with the focal KEGG term in the module, divided by the equivalent proportion in the gene universe. -->

<!-- #### GO Biological process -->
<!-- ```{r module_enrich2, fig.height = 8, fig.width=9, message=FALSE, warning=FALSE, results='hide'} -->
<!-- fig_S6 <- module_GO_table_dmel %>%  -->
<!--   filter(Ontology == "GO:BP", Module %in% mods) %>%  -->
<!--   module_enrichment_plot()   -->
<!-- # saveRDS(fig_S6, file = "supplement/fig_S6.rds") -->
<!-- fig_S6 -->
<!-- ``` -->
<!-- <br></br> -->
<!-- **Figure SX**: Comparable figure to Figure 4, showing the results of GO: Biological process enrichment analysis instead of KEGG pathways.  -->

<!-- #### GO Molecular function -->
<!-- ```{r module_enrich3, fig.height = 8, fig.width=9, message=FALSE, warning=FALSE, results='hide'} -->
<!-- fig_S7 <- module_GO_table_dmel %>%  -->
<!--   filter(Ontology == "GO:MF", Module %in% mods) %>%  -->
<!--   module_enrichment_plot()   -->
<!-- # saveRDS(fig_S7, file = "supplement/fig_S7.rds") -->
<!-- fig_S7 -->
<!-- ``` -->
<!-- <br></br> -->
<!-- **Figure SX**: Comparable figure to Figure 4, showing the results of GO: Molecular function enrichment analysis instead of KEGG pathways.  -->

<!-- #### GO Cellular component -->
<!-- ```{r module_enrich4, fig.height = 8, fig.width=9, message=FALSE, warning=FALSE, results='hide'} -->
<!-- fig_S8 <- module_GO_table_dmel %>%  -->
<!--   filter(Ontology == "GO:CC", Module %in% mods) %>%  -->
<!--   module_enrichment_plot()   -->
<!-- # saveRDS(fig_S8, file = "supplement/fig_S8.rds") -->
<!-- fig_S8 -->
<!-- ``` -->
<!-- <br></br> -->
<!-- **Figure SX**: Comparable figure to Figure 4, showing the results of GO: Cellular component enrichment analysis instead of KEGG pathways. Module 9 is missing because no GO:CC terms were significantly enriched. -->


## Compare our results to past work

```{r results='hide', message=FALSE, warning=FALSE}
source("code/create_merged_data.R")
 
merged_data <- merged_data %>% 
  dplyr::select(-beebase, -gene_name, -beebase, -entrez_id) %>%
  dplyr::select(gene, everything())
```


Correlations across _Apis_ genes in all sorts of variables from various studies:

```{r big_cor_plot, fig.height = 12, fig.width = 12, warning=FALSE}
corrs <- merged_data %>%
  rename_all(~ str_replace_all(.x, "\n", " ")) %>%
  dplyr::select(-gene) %>%
  cor(use = "pairwise.complete.obs")

paletteLength <- 50
myColor <- colorRampPalette(c(brewer.pal(9, "Blues")[6], "white", brewer.pal(9, "Reds")[7]))(paletteLength)
myBreaks <- c(seq(min(corrs, na.rm=T), 0, length.out=ceiling(paletteLength/2) + 1), 
              seq(max(corrs, na.rm=T)/paletteLength, max(corrs, na.rm=T), length.out=floor(paletteLength/2)))

pheatmap(corrs, color = myColor, breaks = myBreaks,
         cutree_rows = 5, cutree_cols = 5)
```


Scatterplots showing some of these same relationships explicitly:

(NB I need to find out what positive logFC means for the Wojciechowski histone data)

```{r scatterplots, fig.height = 16, fig.width = 16}
make_a_plot <- function(yvar, xvar){
  
  merged_data <- merged_data %>%
    dplyr::select(-gene) %>%
    mutate_all( ~ as.numeric(scale((.x))))
  
  names(merged_data)[names(merged_data) == yvar] <- "y"
  names(merged_data)[names(merged_data) == xvar] <- "x"
  
  merged_data <- merged_data %>% 
    dplyr::select(x, y)
  merged_data <- merged_data[complete.cases(merged_data), ]
  merged_data <- merged_data[is.finite(merged_data$y), ]
  if(nrow(merged_data) == 0) return(NULL) 
  
  ylim <- range(merged_data$y)
  ylim[1] <- ylim[1] - (ylim[1]*0.05)
  ylim[2] <- ylim[2] + (ylim[2]*0.05)
  
  p <- ggplot(merged_data, aes(x, y)) + 
    geom_vline(xintercept = 0, linetype = 2, colour = "black") 
  
  if(min(merged_data$y) < 0 ) {
    p <- p + geom_hline(yintercept = 0, linetype = 2, colour = "black")
  }
  
  ylab <- str_remove_all(yvar, "Warner_")
  
  p + stat_bin_hex() + 
    stat_smooth(method = "loess", colour = "tomato", formula = "y ~ x") + 
    scale_fill_viridis_c(option = "D") +
    coord_cartesian(ylim = ylim) + 
    ylab(ylab) + xlab(NULL) + 
    theme_bw(10) + 
    theme(legend.position = "none") 
}
variables <- names(sapply(merged_data, is.numeric)[sapply(merged_data, is.numeric)])

plots_expression <- variables[variables != "Upregulation in queen-destined 8h larvae"] %>%
  sort() %>% lapply(make_a_plot, xvar = "Upregulation in queen-destined 8h larvae") 
plots_expression <- plots_expression[!sapply(plots_expression, is.null)]

plots_meth <- variables[variables != "Caste difference in DNA methylation"] %>%
  sort() %>% lapply(make_a_plot, xvar = "Caste difference in DNA methylation") 
plots_meth <- plots_meth[!sapply(plots_meth, is.null)]

do.call(grid.arrange, c(plots_expression, list(bottom = "Caste bias in expression in 8h larvae (positive = queen-biased)")))

do.call(grid.arrange, c(plots_meth, list(bottom = "Caste bias in DNA methylation in 8h larvae (positive = queen-biased)")))

rm(plots_expression)
rm(plots_meth)
```

<!-- Test idea about the doublesex module in Velasque et al. -->
```{r eval=FALSE}
# Define a function to test whether the overlap of two sets of differentially expressed genes, 
# drawn from a common pool (e.g. all the orthologs that were tested), is higher or lower than expected
# Inspiration for this code: https://stats.stackexchange.com/questions/10328/using-rs-phyper-to-get-the-probability-of-list-overlap
overlap_hypergeometric_test <- function(n_overlaps, n_gene_set1, n_in_set2, overall_n_genes){
  p.higher <- 1 - phyper(n_overlaps - 1, n_gene_set1, overall_n_genes - n_gene_set1, n_in_set2)
 # percent_of_maximum_overlaps <- 100 * n.overlaps / min(c(num.sig1, num.sig2))
  
  exp_n_overlaps <- overall_n_genes * (n_gene_set1 / overall_n_genes) * (n_in_set2 / overall_n_genes)

  data.frame(Test = "Overlap is higher than expected:",
                       obs_n_overlaps = n_overlaps,
                       exp_n_overlaps = round(exp_n_overlaps,1),
                       enrichment_ratio = round(n_overlaps / exp_n_overlaps, 2),
                       p = round(p.higher,4)
                       )
}

velasque_gene_universe <- read_csv("https://raw.githubusercontent.com/MikheyevLab/dsx-rnai/master/data/genes_tpm.csv") %>%
  pull (gene_id)

# 9386 genes in common between our two studies
shared_gene_universe <- intersect(rownames(expression_data), velasque_gene_universe)

# Find overlaps with our expression modules, and the dsx-containing module in velasque et al
module_overlaps <- read_csv("output/caste_results.csv") %>%
  filter(`Gene symbol` %in% shared_gene_universe) %>%
  filter(Time == 8) %>%   # Just od time 8h for now
  left_join(read_csv("data/apis_gene_comparisons/velasque_doublesex.csv") %>% 
              mutate(dsx_module = "yes") %>% dplyr::select(gene, dsx_module), 
            by = c(`Gene symbol` = "gene")) %>%
  mutate(dsx_module = replace(dsx_module, is.na(dsx_module), "no")) %>%
  group_by(module, dsx_module) %>%
  summarise(n=n(), .groups = "drop") %>%
  arrange(module, dsx_module) 

shared_gene_universe_meth <- intersect(
  readRDS(file = "output/gene_meth_module_memberships.rds")$gene, 
  velasque_gene_universe)
  

# Find overlaps with our METHYLATION modules, and the dsx-containing module in velasque et al
module_overlaps_meth <- readRDS(file = "output/gene_meth_module_memberships.rds") %>%
  filter(gene %in% shared_gene_universe_meth) %>%
  left_join(read_csv("data/apis_gene_comparisons/velasque_doublesex.csv") %>% 
              mutate(dsx_module = "yes") %>% dplyr::select(gene, dsx_module), 
            by = "gene") %>%
  mutate(dsx_module = replace(dsx_module, is.na(dsx_module), "no")) %>%
  group_by(module, dsx_module) %>%
  summarise(n=n(), .groups = "drop") %>%
  arrange(module, dsx_module) 


n_genes_in_dsx_module <- sum(with(module_overlaps, n[dsx_module == "yes"]))
  
module_overlaps %>%
  split(.$module) %>%
  map_df(function(x){
    
    present_study_module_size <- sum(x$n)
    n_overlaps <- with(x, n[dsx_module == "yes"])
    
    data.frame(Module = x$module[1],
    overlap_hypergeometric_test(n_overlaps, 
                                n_genes_in_dsx_module, 
                                present_study_module_size, 
                                length(shared_gene_universe)))
    
  }) %>% arrange(-enrichment_ratio) %>% 
  mutate(p_adjust = p.adjust(p, method = "BH")) %>%
  filter(p_adjust < 0.05)

# for methylation:
module_overlaps_meth %>%
  split(.$module) %>%
  keep(~ nrow(.x) > 1) %>%
  map_df(function(x){
    
    present_study_module_size <- sum(x$n)
    n_overlaps <- with(x, n[dsx_module == "yes"])
    
    data.frame(Module = x$module[1],
    overlap_hypergeometric_test(n_overlaps, 
                                n_genes_in_dsx_module, 
                                present_study_module_size, 
                                length(shared_gene_universe)))
    
  }) %>% arrange(-enrichment_ratio) %>% 
  mutate(p_adjust = p.adjust(p, method = "BH")) %>%
  filter(p_adjust < 0.05)



# Comparison with doublesex module in velasque et al. https://www.biorxiv.org/content/10.1101/314492v1.full
read_csv("output/caste_results.csv") %>%
  filter(adj.P.Val <= 0.05) %>%
  right_join(read_csv("data/apis_gene_comparisons/velasque_doublesex.csv"), b
             y = c(`Gene symbol` = "gene")) %>%
  filter(!is.na(kWithin) & !is.na(logFC.x)) %>%
  filter(Time == 8) %>% print(n=Inf)


x <- read_tsv("~/Downloads/Methldiff_t0q8.txt")
e %>% full_join(caste_results %>% filter(Time==8), by = c("Genes" = "Gene symbol")) %>% 
  filter(adj.P.Val < 0.05) %>%
  filter(qvalue < 0.05) %>%
  group_by(Genes) %>%
  summarise(n=n(), .groups = "drop")

x %>% 
  filter(qvalue < 0.05) %>%
  full_join(caste_results %>% 
                  filter(Time==8 & adj.P.Val <= 0.05), # 8h sig genes
                by = c("Genes" = "Gene symbol"))  %>%
  mutate(type = case_when(
    !is.na(meth.diff) & !is.na(logFC) ~ "both",
    !is.na(meth.diff) & is.na(logFC) ~ "meth only",
    is.na(meth.diff) & !is.na(logFC)  ~ "expr only"
  )) %>% pull(type) %>% table()


caste_results %>% filter(Time==8) %>% pull(`Gene symbol`) %>% unique %>% length()
x %>% pull(Genes) %>% unique %>% length()

overlap_hypergeometric_test(415, 415+2014, 415+1195, nrow(expression_data))

# Load all the QvsW at each time point tests
meth_data <- map(c(2,4,6,8), function(i) {
  glue::glue("/Users/lholman/Downloads/Methylation/Caste\ specific\ results/Routput-q{i}w{i}/DMSG/dmg-Am_HE_queen{i}.vs.worker{i}_details.txt") %>%
    read_tsv() %>%
    mutate(Time = i) %>% 
    dplyr::rename_at(vars(starts_with("queen")), ~ "queen" ) %>% 
    dplyr::rename_at(vars(starts_with("worker")), ~ "worker")
}) %>% 
  bind_rows() %>%
  select(Time, everything()) %>%
  select(-width, -strand, -coverage1, -coverage2) # width is always 1, strand is always +. Coverage is just Cs + Ts

with(meth_data, paste(seqnames, start)) %>% unique %>% length()

meth_data %>%
  group_by(Time) %>% summarise(n(), .groups = "drop")

meth_data %>%
  arrange(-abs(queen-worker))

meth_data %>%
  mutate(
    cluster = kmeans(10^10*as.numeric(as.factor(meth_data$seqnames)) + meth_data$start, 224)$cluster 
  ) %>%
  ggplot(aes(start, queen-worker, fill = queen-worker, group=1, size = is.dm)) + 
  geom_hline(yintercept = 0) + 
  geom_point(pch = 21) +
 # geom_point(aes(y=worker), colour = "red") +
  facet_wrap(~ cluster, scales = "free_x") + 
  scale_fill_gradient2() + 
  theme(strip.background = element_blank(),
        strip.text = element_blank())


xx <- read_tsv("/Users/lholman/Downloads/Methylation/Caste\ specific\ results/Routput-q8w8/DMSG/dmg-Am_HE_queen8.vs.worker8_details.txt")

dmr <- xx %>% filter(is.dm) %>% as.data.frame()

dmr %>% pull(gene_Name) -> dm_genes
  select(gene_start, gene_end) %>%
  mutate(site = 1:n()) %>%
  gather(metric, position, -site) %>%
  ggplot(aes(position, y=1, group = site)) +
    geom_line()
  
# meth counts for genes:
files <- list.files("/Users/lholman/Downloads/Methylation", pattern = "ogl-Am_HE", recursive = T, full.names = T) 
files <- files[!grepl("vs", files)]
files <- files[!grepl("OGLall", files)]
meth_genes <- map_df(files, ~ read_tsv(.x) %>% 
         mutate(caste = "t0",
                caste = replace(caste, str_detect(.x, "queen"), "queen"),
                caste = replace(caste, str_detect(.x, "worker"), "worker"),
                time = as.numeric(str_remove_all(unlist(str_extract_all(.x, "[:digit:][.]txt")), "[.]txt")),
                file = .x)) %>%
  mutate(gene_ID = str_remove_all(gene_ID, "gene[-]")) %>%
  distinct(gene_ID, caste, time, .keep_all = TRUE) %>%
  dplyr::arrange(gene_ID, caste, time)


meth_test_one_gene <- function(gene){
  focal_data <- meth_genes %>% 
    filter(gene_ID == gene & caste != "t0") %>% 
    mutate(percent_meth = `%perSite`)

  response <- cbind(focal_data$percent_meth,
                    100 - focal_data$percent_meth) %>% round()
  focal_data
}

meth_test_one_gene("Snf")
```



<!-- From Wojciechowski et al. 2018 Genome Biology https://genome.cshlp.org/content/early/2018/08/20/gr.236497.118.full.pdf+html -->
<!-- We find that genes differentially enriched with H3K4me3 -->
<!-- (rho = 0.28; P-value = 2.7 × 10−17) and H3K36me3 (rho = 0.15; P-value = -->
<!-- 4.6 × 10−5 -->
<!-- ) show significant correlation with transcriptional differences, suggesting that caste-specific H3K4me3 and H3K36me3 -->
<!-- patterns associate with caste-specific transcriptional profiles (Fig. -->
<!-- 2D). In contrast, genes differentially enriched with H3K27ac -->
<!-- show a nonsignificant correlation with caste-specific transcriptional differences (rho = 0.04; P-value = 0.074). -->


