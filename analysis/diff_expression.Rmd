---
title: "Analysis of the RNA-seq data"
output: 
  workflowr::wflow_html:
    code_folding: hide 
---


## Load R packages and the expression data
```{r pkgs, results='hide', message=FALSE, warning=FALSE}
# All but 1 of these packages can be easily installed from CRAN or Bioconductor
# However it was slightly harder to install the showtext package. On Mac, I did this:
# installed 'homebrew' using Terminal: ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)" 
# installed 'libpng' using Terminal: brew install libpng
# installed 'showtext' in R using: devtools::install_github("yixuan/showtext")  
library(showtext)

# Run these to install from Bioconductor:
# BiocManager::install("AnnotationHub") 
# BiocManager::install("edgeR")
# BiocManager::install("clusterProfiler")
# BiocManager::install("WGCNA")
library(tidyverse)
library(brms)
library(edgeR) # install with BiocManager::install("edgeR") 
library(dbplyr)
library(DBI)
library(RSQLite)
library(gplots)
library(gridExtra)
library(ecodist)
library(WGCNA) # 
library(clusterProfiler) 
library(RColorBrewer)
library(pander)
library(kableExtra)
library(DT)
library(reshape2)
library(UpSetR)
library(pheatmap)
library(RColorBrewer)
library(ggrepel)
library(broom)
library(sva)
library(glue)
library(fgsea) # for enrichment tests; source("https://bioconductor.org/biocLite.R"); biocLite("fgsea") 


# set up nice font for figure
nice_font <- "Lora"
font_add_google(name = nice_font, family = nice_font, regular.wt = 400, bold.wt = 700)
showtext_auto()

# define colours
queen_colour <- "#d13b40"
worker_colour <- RColorBrewer::brewer.pal(7, "Blues")[4]

# Make html tables:
my_data_table <- function(df){
  datatable(
    df, rownames=FALSE,
    autoHideNavigation = TRUE,
    extensions = c("Scroller",  "Buttons"),
    options = list(
      dom = 'Bfrtip',
      deferRender=TRUE,
      scrollX=TRUE, scrollY=400,
      scrollCollapse=TRUE,
      buttons = 
        list('pageLength', 'colvis', 'csv', list(
          extend = 'pdf',
          pageSize = 'A4',
          orientation = 'landscape',
          filename = 'Apis_expression')),
      pageLength = 50
    )
  )
}


kable_table <- function(df) {
  kable(df, "html") %>%
  kable_styling() %>%
  scroll_box(height = "300px")
}

# Database with useful gene name conversion table, GO terms etc.
db <- dbConnect(SQLite(), "data/apis_db.sqlite3") # DBI::dbListTables(db)

# Load the RSEM expression_data for each sample-gene combination
expression_data <- as.matrix(read.table("data/Expression_data/Genes_2020_version.txt", row.names = 1, header = T))
n_genes_before_filtering <- nrow(expression_data)
gsg <- goodSamplesGenes(t(expression_data), verbose = 3) # exclude 217 genes due to too many missing samples or zero variance
expression_data <- expression_data[gsg$goodGenes, gsg$goodSamples]


# Extract key information from the sample names
sample_ids <- data.frame(
  sample_name = colnames(expression_data),
  caste = ifelse(grepl("w", colnames(expression_data)), "Worker", "Queen"),
  time_point = str_extract(colnames(expression_data), "[02468]"),
  replicate = gsub("_", "", str_extract(colnames(expression_data), "_[ABCD]")),
  stringsAsFactors = TRUE) %>%
  mutate(caste = replace(as.character(caste), str_detect(colnames(expression_data), "t0"), "Time zero"),
         #time_point = as.numeric(as.character(time_point)),
         time_point = relevel(factor(time_point), ref = 2),
         queen_cell = ifelse(caste == "Queen","Yes", "No"),
         worker_cell = ifelse(caste == "Worker", "Yes", "No"))
```

```{r echo = FALSE}
# knitr::opts_chunk$set(cache = TRUE)
# knitr::opts_chunk$set(autodep = TRUE)
```



## Data checks and pre-processing

### Filter out low-expression genes
```{r filter_genes}
# filter genes for which maximum expression level is less than 1 Count Per Million 
voom_gene_data <- calcNormFactors(DGEList(expression_data))
voom_gene_data <- voom_gene_data[-which(apply(cpm(voom_gene_data), 1, max) < 1),] 

genes_kept <- rownames(voom_gene_data@.Data[[1]])
expression_data <- expression_data[rownames(expression_data) %in% genes_kept, ]
n_genes_after_filtering <- unique(c(nrow(voom_gene_data), nrow(expression_data)))

tibble(` ` = c("Number of transcripts prior to filtering:", 
               "Number remaining after filtering out transcripts where max(CPM) < 1 or too many samples are missing:"),
       n = c(n_genes_before_filtering, n_genes_after_filtering)) %>% pander()
```

## Exploratory plots of the transcriptome data

### Reduce and plot the transcriptomes using NMDS

```{r nmds_transcriptome}
nmds_output <- dist(t(expression_data)) %>% nmds(maxdim = 3)
nmds_r2 <- tail(nmds_output$r2, 1)
nmds_output <- data.frame(Caste = sample_ids$caste,
                          Time = as.numeric(as.character(sample_ids$time_point)),
                          Replicate = paste("Replicate", sample_ids$replicate),
                          label = paste(sample_ids$caste, sample_ids$time_point),
                          nmds_output$conf[[length(nmds_output$conf)]]) %>%
  mutate(X1 = as.numeric(scale(X1)),
         X2 = as.numeric(scale(X2)),
         X3 = as.numeric(scale(X3))) %>%
  rename(`NMDS 1` = X1, `NMDS 2` = X2, `NMDS 3` = X3)

t0_dat <- nmds_output %>% filter(Time == 0) %>%
  gather(NMDS, Score, starts_with("NMDS"))

bind_rows(nmds_output %>% filter(Time == 0) %>% mutate(Caste = "Queen"),
          nmds_output %>% filter(Time == 0) %>% mutate(Caste = "Worker"),
          nmds_output %>% filter(Caste != "Time zero")) %>%
  gather(NMDS, Score, starts_with("NMDS")) %>%
  mutate(Caste = factor(Caste, c("Queen", "t0", "Worker"))) %>%
  # mutate(NMDS = gsub("X", "NMDS ", NMDS),
  #        Replicate = paste("Replicate", Replicate)) %>%
  ggplot(aes(Time, Score, colour = Caste, group = Caste)) + 
  geom_line() +
  geom_point() + 
  geom_point(data =t0_dat, colour = "grey60") + 
  scale_colour_manual(values = c(queen_colour, "grey60", worker_colour), 
                      name = "Cell type", drop = FALSE) + 
  facet_grid(NMDS~Replicate) + 
  xlab("Time since the larva was grafted (hours)") + 
  theme_bw()
```

**Figure**: Results of non-metric multidimensional scaling analysis, which reduces the distance matrix between samples to three dimensions (termed NMDS 1-3; $r^2 =$ `r nmds_r2`). The plot suggests that queen- and worker-destined larvae have different gene expression profiles and that the transcriptome changes over time, and there is some indication that the caste difference is larger at later times post-grafting into a queen or worker cell. 


### Heatmap showing similarities between samples and genes

```{r bigheatmap, fig.height=6.4, fig.width=8.7, message=F, warning=F}
# Convert the gene expression values to a fraction of total for each sample
scaled_expression_data <- expression_data
for(i in 1:ncol(scaled_expression_data)) {
  scaled_expression_data[,i] <- 100 * scaled_expression_data[,i] / sum(scaled_expression_data[,i])
}

# Scale to have mean 0, variance 1
for(i in 1:nrow(scaled_expression_data)) {
  scaled_expression_data[i, ] <- as.numeric(scale(scaled_expression_data[i,]))
}

name_converter <- sample_ids %>%
  mutate(new_name = paste(caste, " ", time_point, "h rep", replicate, sep = ""),
         new_name = str_replace_all(new_name, " 0h", "")) %>%
  dplyr::select(sample_name, new_name, caste) %>%
  mutate(caste = replace(caste, caste == "Time zero", "t0"))

rownames(scaled_expression_data) <- NULL
colnames(scaled_expression_data) <- name_converter$new_name[match(colnames(scaled_expression_data), name_converter$sample_name)]


# Remove batch effects using sva::Combat
pheno <- tibble(sample = colnames(scaled_expression_data),
                caste = factor(substr(sample, 1, 1)), 
                time = str_extract(sample, "[02468]"),
                caste_time = paste(caste, time),
                rep = substr(sample, nchar(sample), nchar(sample))) 
batch <- pheno$rep
mod <- model.matrix(~ caste_time, data=pheno)

scaled_expression_data <- invisible(ComBat(dat = scaled_expression_data, 
                                             batch = batch, 
                                             mod = mod, 
                                             par.prior = TRUE))

# Re-scale to have mean 0, variance 1
for(i in 1:nrow(scaled_expression_data)) {
  scaled_expression_data[i, ] <- as.numeric(scale(scaled_expression_data[i,]))
}

paletteLength <- 50
myColor <- colorRampPalette(c(brewer.pal(9, "Purples")[7], "white", brewer.pal(9, "Oranges")[7]))(paletteLength)
myBreaks <- c(seq(min(scaled_expression_data, na.rm=T), 0, length.out=ceiling(paletteLength/2) + 1), 
              seq(max(scaled_expression_data, na.rm=T)/paletteLength, max(scaled_expression_data, na.rm=T), length.out=floor(paletteLength/2)))


annotation_row <- name_converter %>% select(new_name, caste) %>% as.data.frame()
rownames(annotation_row) <- annotation_row$new
annotation_row <- annotation_row %>% 
  select(caste) %>% dplyr::rename(` ` = caste)


annotation_colors <- 
  list(` ` = c(Queen = queen_colour, t0 = "grey60", Worker = worker_colour))

t(scaled_expression_data) %>%
  pheatmap(col = myColor, breaks = myBreaks,
           clustering_distance_rows = "euclidean",
           clustering_distance_cols = "euclidean",
           cutree_cols = 18, cutree_rows = 5, 
           annotation_row = annotation_row, annotation_colors = annotation_colors,
           show_colnames = FALSE)
```

**Figure XX:** Heatmap showing the transcriptome of each sample, where each column indicates one of the `r nrow(scaled_expression_data)` transcripts, and orange and purple indicate above- and below-average expression respectively. The expression level of gene $j$ in sample $i$ was first converted to a proportion of the total, then batch effects were removed using `sva::ComBat`, and finally the data for each transcript were mean-centered and scaled to unit standard deviation. The QDL and WDL samples mostly cluster together, and extensive co-expression among transcripts is apparent.


## Detecting differential expression with `limma::voom`

### Run the linear models

The formula used for the linear models is: `caste * time_point + replicate`. We then use this model to compute planned contrasts that test for a caste difference at each time point (2h, 4h, 6h, 8h), as well as to measure the ccaste-specific effect of time on gene expression (e.g. we test for changes in expression between 2h and 8h, separately in queens and workers).

In the following tables, a **positive** log fold change in expression indicates **higher expression in queens** vs workers (for caste comparisons) or **higher expression at later times** than earlier times (for temporal comparisons).

```{r voom}
voom_gene_data <- calcNormFactors(DGEList(expression_data))

# Set up model matrix. NB "replicate" is treated with sum constrasts, since no one replicate is 
# a meaningful comparison point (we use time 2h as the baseline for time, and queens as basis for caste)
mm <- model.matrix(~ queen_cell * time_point + replicate, 
                   data = sample_ids , 
                   contrasts = list(replicate = "contr.sum")) 

mm <- mm[, !grepl("queen_cellYes:time_point0", colnames(mm))]

colnames(mm) <- gsub("caste", "", colnames(mm))
voom_gene_fit <- voom_gene_data %>% voom(mm, plot = FALSE) %>% lmFit(mm)

contrast_matrix <- cbind(
  Time_zero = c(1,0,1,0,0,0,0,0,0,0,0,0),
  Queen_2 =   c(1,1,0,0,0,0,0,0,0,0,0,0),
  Queen_4 =   c(1,1,0,1,0,0,0,0,0,1,0,0),
  Queen_6 =   c(1,1,0,0,1,0,0,0,0,0,1,0),
  Queen_8 =   c(1,1,0,0,0,1,0,0,0,0,0,1),
  
  Worker_2 =   c(1,0,0,0,0,0,0,0,0,0,0,0),
  Worker_4 =   c(1,0,0,1,0,0,0,0,0,0,0,0),
  Worker_6 =   c(1,0,0,0,1,0,0,0,0,0,0,0),
  Worker_8 =   c(1,0,0,0,0,1,0,0,0,0,0,0)) %>% 
  as.data.frame() %>%
  mutate(
    Caste_2 = Queen_2 - Worker_2,
    Caste_4 = Queen_4 - Worker_4,
    Caste_6 = Queen_6 - Worker_6,
    Caste_8 = Queen_8 - Worker_8,
    
    Queen_0vs2 = Queen_2 - Time_zero,
    Queen_0vs4 = Queen_4 - Time_zero,
    Queen_0vs6 = Queen_6 - Time_zero,
    Queen_0vs8 = Queen_8 - Time_zero,
    
    Queen_2vs4 = Queen_4 - Queen_2,
    Queen_2vs6 = Queen_6 - Queen_2,
    Queen_2vs8 = Queen_8 - Queen_2,
    
    Queen_4vs6 = Queen_6 - Queen_4,
    Queen_4vs8 = Queen_8 - Queen_4,
    
    Queen_6vs8 = Worker_2 - Queen_6,
    
    Worker_0vs2 = Worker_2 - Time_zero,
    Worker_0vs4 = Worker_4 - Time_zero,
    Worker_0vs6 = Worker_6 - Time_zero,
    Worker_0vs8 = Worker_8 - Time_zero,
    
    Worker_2vs4 = Worker_4 - Worker_2,
    Worker_2vs6 = Worker_6 - Worker_2,
    Worker_2vs8 = Worker_8 - Worker_2,
    
    Worker_4vs6 = Worker_6 - Worker_4,
    Worker_4vs8 = Worker_8 - Worker_4,
    
    Worker_6vs8 = Worker_8 - Worker_6)


get_results <- function(voom_fit, column){
  voom_fit %>%
    contrasts.fit(contrast_matrix[, names(contrast_matrix) == column]) %>%
    eBayes() %>%
    topTable(n = Inf) %>% 
    rownames_to_column("Gene")
}

caste_results <- rbind(
  get_results(voom_gene_fit, "Caste_2") %>% mutate(Time = 2),
  get_results(voom_gene_fit, "Caste_4") %>% mutate(Time = 4),
  get_results(voom_gene_fit, "Caste_6") %>% mutate(Time = 6),
  get_results(voom_gene_fit, "Caste_8") %>% mutate(Time = 8)) %>%
  left_join(tbl(db, "gene_names") %>% 
              dplyr::select(gene_symbol, gene_name) %>% 
              collect(n=Inf), 
            by = c("Gene" = "gene_symbol")) %>%
  rename(`Gene name` = gene_name,
         `Gene symbol` = Gene) %>%
  as_tibble() %>% select(Time, `Gene symbol`, `Gene name`, everything()) 

time_results <- rbind(
  get_results(voom_gene_fit, "Queen_0vs2") %>% 
    mutate(Caste = "Queen", Time = "0 vs 2"),
  get_results(voom_gene_fit, "Queen_0vs4") %>% 
    mutate(Caste = "Queen", Time = "0 vs 4"),
  get_results(voom_gene_fit, "Queen_0vs6") %>% 
    mutate(Caste = "Queen", Time = "0 vs 6"),
  get_results(voom_gene_fit, "Queen_0vs8") %>% 
    mutate(Caste = "Queen", Time = "0 vs 8"),
  get_results(voom_gene_fit, "Queen_2vs4") %>% 
    mutate(Caste = "Queen", Time = "2 vs 4"),
  get_results(voom_gene_fit, "Queen_2vs6") %>% 
    mutate(Caste = "Queen", Time = "2 vs 6"),
  get_results(voom_gene_fit, "Queen_2vs8") %>% 
    mutate(Caste = "Queen", Time = "2 vs 8"),
  get_results(voom_gene_fit, "Queen_4vs6") %>% 
    mutate(Caste = "Queen", Time = "4 vs 6"),
  get_results(voom_gene_fit, "Queen_4vs8") %>% 
    mutate(Caste = "Queen", Time = "4 vs 8"),
  get_results(voom_gene_fit, "Queen_6vs8") %>% 
    mutate(Caste = "Queen", Time = "6 vs 8"),
  
  get_results(voom_gene_fit, "Worker_0vs2") %>% 
    mutate(Caste = "Worker", Time = "0 vs 2"),
  get_results(voom_gene_fit, "Worker_0vs4") %>% 
    mutate(Caste = "Worker", Time = "0 vs 4"),
  get_results(voom_gene_fit, "Worker_0vs6") %>% 
    mutate(Caste = "Worker", Time = "0 vs 6"),
  get_results(voom_gene_fit, "Worker_0vs8") %>% 
    mutate(Caste = "Worker", Time = "0 vs 8"),
  get_results(voom_gene_fit, "Worker_2vs4") %>% 
    mutate(Caste = "Worker", Time = "2 vs 4"),
  get_results(voom_gene_fit, "Worker_2vs6") %>% 
    mutate(Caste = "Worker", Time = "2 vs 6"),
  get_results(voom_gene_fit, "Worker_2vs8") %>% 
    mutate(Caste = "Worker", Time = "2 vs 8"),
  get_results(voom_gene_fit, "Worker_4vs6") %>% 
    mutate(Caste = "Worker", Time = "4 vs 6"),
  get_results(voom_gene_fit, "Worker_4vs8") %>% 
    mutate(Caste = "Worker", Time = "4 vs 8"),
  get_results(voom_gene_fit, "Worker_6vs8") %>% 
    mutate(Caste = "Worker", Time = "6 vs 8")) %>%
  left_join(tbl(db, "gene_names") %>% 
              select(gene_symbol, gene_name) %>% 
              collect(n=Inf), 
            by = c("Gene" = "gene_symbol")) %>%
  rename(`Gene name` = gene_name,
         `Gene symbol` = Gene) %>%
  as_tibble() %>% 
  select(Caste, Time, `Gene symbol`, `Gene name`, everything())
```


```{r eval=F, echo=F}
corrrs <- cor(t(expression_data), method = "spearman") %>%
  as.data.frame() %>%
  rownames_to_column("other_gene") %>% as_tibble() %>%
  gather(focal_gene, correlation, -other_gene) %>%
  filter(focal_gene != other_gene) %>% select(focal_gene, other_gene, correlation)


plot_corr_hist <- function(genes){
  corrrs %>%
    filter(focal_gene %in% genes) %>%
    ggplot(aes(correlation)) + 
    geom_histogram(bins = 100) + 
    scale_x_continuous(limits = c(-1,1)) + 
    facet_wrap(~ focal_gene)
}

plot_corr_hist(c("Csd", "Dnmt1a", "Dnmt3", "Dsx", "Dl", "tra2", "Mrjp1", "Mrjp2", "5-HT1"))
# 
# median_corrs <- corrrs %>%
#   group_by(focal_gene) %>%
#   summarise(median_corr = mean(correlation)) %>%
#   arrange(median_corr)
# 
# median_corrs %>%
#   left_join(caste_results %>% filter(Time ==8), by = c("focal_gene" = "Gene symbol")) %>% 
#   ggplot(aes(median_corr, logFC)) + 
#   geom_point()
# 
# rand <- corrrs$focal_gene[sample(nrow(corrrs), 25)] %>%sort()
# plot_corr_hist("LOC724565")
# 
# tbl(db, "gene_names") %>% filter(gene_symbol == "LOC724565")
```


## Significantly differentially expressed gene lists

### Counting the significant genes

#### Genes showing a difference between QDL and WDL by timepoint
```{r}
caste_results %>%
  filter(adj.P.Val < 0.05) %>%
  group_by(Time) %>%
  summarise(n_significant_genes = n(), .groups = "drop") %>%
  dplyr::rename(Comparison = Time) %>%
  mutate(Comparison = glue("QDL vs WDL ({Comparison}h)")) %>%
  kable_table() %>%
  kable_styling(full_width = F)
```

#### Genes showing a difference between timepoints by caste
```{r}
time_results %>%
  filter(adj.P.Val < 0.05) %>%
  group_by(Caste, Time) %>%
  summarise(n_significant_genes = n(), .groups = "drop") %>% 
    dplyr::rename(Comparison = Time) %>%
    mutate(Comparison = glue("{Caste} ({Comparison}h)"),
           Comparison = str_replace_all(Comparison, " vs", "h vs"),
           Comparison = str_replace_all(Comparison, "Queen", "QDL"),
           Comparison = str_replace_all(Comparison, "Worker", "WDL")) %>%
  ungroup() %>%
  dplyr::select(Comparison, n_significant_genes) %>%
  kable_table() %>%
  kable_styling(full_width = F)
```


### Caste-specific genes

You can also view this table on a full web page [here](caste_table.html), or press the buttons to export the table to PDF, .csv, or Excel formats.

```{r intersections}
get_intersections <- function(results_df, split_by){
  results_df <- results_df %>%
    mutate(Gene = paste(`Gene symbol`, `Gene name`, sep = "~~")) %>%
    filter(adj.P.Val <= 0.05)
  splitter <- results_df %>% pull(!! split_by)
  sig_genes <- results_df %>%
    pull(`Gene`) %>%
    split(splitter)
  
  names(sig_genes) <- unique(splitter)
  ven <- venn(sig_genes, show.plot = FALSE)
  attr(ven, "intersections")
}


get_intersections(caste_results, "Time") %>% melt() %>% 
  mutate(
    `Hour(s) with a significant caste difference:` = gsub(":", ", ", L1),
    split = strsplit(as.character(value), split = "~~"),
    `Gene symbol` = map_chr(split, ~ .x[1]),
    `Gene name` = map_chr(split, ~ .x[2])) %>% 
  select(`Gene symbol`, `Gene name`, 
         `Hour(s) with a significant caste difference:`) %>% 
  as_tibble() %>%
  left_join(
    caste_results %>%
      select(`Gene symbol`, Time, logFC) %>%
      distinct() %>%
      spread(Time, logFC) %>%
      rename_at(vars(-`Gene symbol`), ~ paste("logFC at ", .x, "h", sep = "")),
    by = "Gene symbol") %>%
  arrange(-abs(`logFC at 2h` + `logFC at 4h` + `logFC at 6h` + `logFC at 8h`)) %>%
  mutate_at(vars(starts_with("logFC")), ~ round(.x, 2)) %>%
  my_data_table()
```

### Temporally-variable genes in queen-destined larvae

You can also view this table on a full web page [here](queen_time_table.html), or press the buttons to export the table to PDF, .csv, or Excel formats.

```{r temporal_Q}
time_results %>% 
  filter(Caste == "Queen") %>%
  get_intersections("Time") %>% 
  melt() %>% 
  mutate(
    `Significant temporal comparisons:` = gsub(":", "; ", L1),
    split = strsplit(as.character(value), split = "~~"),
    `Gene symbol` = map_chr(split, ~ .x[1]),
    `Gene name` = map_chr(split, ~ .x[2])) %>% 
  select(`Gene symbol`, `Gene name`, `Significant temporal comparisons:`) %>% 
  arrange(-nchar(`Significant temporal comparisons:`),
          `Significant temporal comparisons:`) %>% as_tibble() %>%
  left_join(
    time_results %>%
      filter(Caste == "Queen") %>%
      select(`Gene symbol`, Time, logFC) %>%
      distinct() %>%
      spread(Time, logFC) %>%
      rename_at(vars(-`Gene symbol`), ~ paste("logFC: ", .x, "h", sep = "")),
    by = "Gene symbol") %>%
  mutate_at(vars(starts_with("logFC")), ~ round(.x, 2)) %>%
  my_data_table()
```

### Temporally-variable genes in worker-destined larvae

You can also view this table on a full web page [here](worker_time_table.html), or press the buttons to export the table to PDF, .csv, or Excel formats.

```{r temporal_W}
time_results %>% 
  filter(Caste == "Worker") %>%
  get_intersections("Time") %>% 
  melt() %>% 
  mutate(
    `Significant temporal comparisons:` = gsub(":", "; ", L1),
    split = strsplit(as.character(value), split = "~~"),
    `Gene symbol` = map_chr(split, ~ .x[1]),
    `Gene name` = map_chr(split, ~ .x[2])) %>% 
  select(`Gene symbol`, `Gene name`, `Significant temporal comparisons:`) %>% 
  arrange(-nchar(`Significant temporal comparisons:`),
          `Significant temporal comparisons:`) %>% as_tibble() %>%
  left_join(
    time_results %>%
      filter(Caste == "Queen") %>%
      select(`Gene symbol`, Time, logFC) %>%
      distinct() %>%
      spread(Time, logFC) %>%
      rename_at(vars(-`Gene symbol`), ~ paste("logFC: ", .x, "h", sep = "")),
    by = "Gene symbol") %>%
  mutate_at(vars(starts_with("logFC")), ~ round(.x, 2)) %>%
  # datatable(options = list(pageLength = 10), rownames = FALSE, filter = 'top', fillContainer = TRUE)
  datatable(rownames = FALSE, filter = 'top', fillContainer = TRUE,
            extensions = 'Buttons', options = list(
              dom = 'Bfrtip', pageLength = 10,
              buttons = c('copy', 'csv', 'excel', 'pdf')))
```


<!-- ## Overlaps in differential expression -->

<!-- ### UpSet plot -->

<!-- The plot shows the number of significantly differentially expressed genes for each comparison, and the number of these that intersect for each pair of comparisons (similar to a Venn diagram, expect it can handle more categories). -->

<!-- ```{r upset, fig.height=7} -->
<!-- caste_results %>%  -->
<!--   mutate(Caste = "Caste difference",  -->
<!--          Time = paste(Time, "h", sep = "")) %>%  -->
<!--   select(Caste, Time, `Gene symbol`,  -->
<!--          `Gene name`, adj.P.Val) %>% -->
<!--   bind_rows( -->
<!--     time_results %>%  -->
<!--       select(Caste, Time, `Gene symbol`,  -->
<!--              `Gene name`, adj.P.Val) %>% -->
<!--       mutate(Time = paste( -->
<!--         substr(Time,1,1),  -->
<!--         "h", substr(Time,2,nchar(Time)), "h", sep = ""))) %>% -->
<!--   filter(adj.P.Val <= 0.05) %>%  -->
<!--   mutate(Comparison = paste(Caste, Time)) %>% -->
<!--   split(.$Comparison) %>% -->
<!--   map(~ .x %>% pull(`Gene symbol`)) %>% -->
<!--   fromList() %>% -->
<!--   upset(order.by = "freq", nsets = 999)  -->
<!-- ``` -->

<!-- ### Correlations in log fold differences in expression -->

<!-- The figure plots each possible pairwise comparison for within and between castes, e.g. the Queen 6 vs 8 variable gives the log fold difference in gene expression that was estimated between the 6h and 8h queen samples that was estimated by `voom`. Note that many of the genes that increased in expression at times 0-6h in queens, and also genes in which queens have higher expression than workers, actually decrease in expression between 6h and 8h in queens (one can also see this in the eigengenes figure below).  -->

<!-- ```{r cor_lfc, warning=FALSE, fig.height=10, fig.width=12} -->
<!-- corr_mat <- ( -->
<!--   caste_results %>%  -->
<!--     mutate(Caste = "Queen vs worker",  -->
<!--            Time = as.character(Time)) %>%  -->
<!--     select(Caste, Time, `Gene symbol`, `Gene name`, logFC) %>% -->
<!--     bind_rows(time_results %>%  -->
<!--                 select(Caste, Time, `Gene symbol`, `Gene name`, logFC)) %>% -->
<!--     mutate(Comparison = paste(Caste, Time)) %>%  -->
<!--     select(`Gene symbol`, Comparison, logFC) %>% distinct() %>% -->
<!--     spread(Comparison, logFC) %>% select(-`Gene symbol`)) %>% -->
<!--   cor() -->

<!-- colors2 <- colorRampPalette( c(rev(brewer.pal(9, "Blues")), -->
<!--                                "white", brewer.pal(9, "Reds")) )(255) -->

<!-- pheatmap(corr_mat, col = colors2,  -->
<!--          cutree_cols = 4,  -->
<!--          cutree_rows = 4,  -->
<!--          labels_row = NULL) -->
<!-- ``` -->


## Enriched pathways among the caste-biased genes 

### Code to run GO and KEGG enrichment

```{r GO_and_KEGG_gsea, warning = FALSE, fig.height=10.1, fig.width = 5.3}
source("code/GO_and_KEGG_gsea.R")

# Run all the enrichment tests:
if(!file.exists("output/expr_gsea_results.rds")){
  
  # Load up the voom differential expression results
  caste_GO_data <- read_csv("output/caste_results.csv") %>%
    dplyr::rename(gene = `Gene symbol`,
                  statistic = logFC) %>%
    dplyr::select(gene, statistic, Time) 
  
  time_GO_data <- read_csv("output/time_results.csv") %>%
    dplyr::rename(gene = `Gene symbol`,
                  statistic = logFC) %>%
    dplyr::select(gene, statistic, Caste, Time) 
  
  # Do the GO and KEGG enrichments (see the file code/GO_and_KEGG_gsea.R)
  p_thresh <- 0.01
  
  # Caste difference, at each time point (A. mellifera annotations)
  GO_Amel_annotations_caste <- rbind(
    caste_GO_data %>% filter(Time == 2) %>%                    
      GO_and_KEGG_gsea(keep.all = TRUE, GO_list = "bee_GO") %>% 
      mutate(Time = 2, Comparison = "Caste"),
    caste_GO_data %>% filter(Time == 4) %>%    
      GO_and_KEGG_gsea(keep.all = TRUE, GO_list = "bee_GO") %>% 
      mutate(Time = 4, Comparison = "Caste"),
    caste_GO_data %>% filter(Time == 6) %>%    
      GO_and_KEGG_gsea(keep.all = TRUE, GO_list = "bee_GO") %>% 
      mutate(Time = 6, Comparison = "Caste"),
    caste_GO_data %>% filter(Time == 8) %>%    
      GO_and_KEGG_gsea(keep.all = TRUE, GO_list = "bee_GO") %>% 
      mutate(Time = 8, Comparison = "Caste")
  ) 
  significant <- GO_Amel_annotations_caste %>% 
    filter(pval < p_thresh) %>% pull(pathway) %>% unique()
  GO_Amel_annotations_caste <- GO_Amel_annotations_caste %>%
    filter(pathway %in% significant)
  
  
  # Caste difference, at each time point (D. melanogaster annotations)
  GO_Dmel_annotations_caste <- rbind(
    caste_GO_data %>% filter(Time == 2) %>%    
      GO_and_KEGG_gsea(keep.all = TRUE, GO_list = "dros_ortho_GO") %>% 
      mutate(Time = 2, Comparison = "Caste"),
    caste_GO_data %>% filter(Time == 4) %>%    
      GO_and_KEGG_gsea(keep.all = TRUE, GO_list = "dros_ortho_GO") %>% 
      mutate(Time = 4, Comparison = "Caste"),
    caste_GO_data %>% filter(Time == 6) %>%    
      GO_and_KEGG_gsea(keep.all = TRUE, GO_list = "dros_ortho_GO") %>% 
      mutate(Time = 6, Comparison = "Caste"),
    caste_GO_data %>% filter(Time == 8) %>%    
      GO_and_KEGG_gsea(keep.all = TRUE, GO_list = "dros_ortho_GO") %>% 
      mutate(Time = 8, Comparison = "Caste")
  ) 
  significant <- GO_Dmel_annotations_caste %>% 
    filter(pval < p_thresh) %>% pull(pathway) %>% unique()
  GO_Dmel_annotations_caste <- GO_Dmel_annotations_caste %>%
    filter(pathway %in% significant)

  
  # Temporal change, in each caste (A. mel)
  GO_Amel_annotations_temporalQ <- time_GO_data %>%         
    filter(Caste == "Queen") %>%
    group_by(gene) %>%
    summarise(statistic = statistic[which.max(abs(statistic))], .groups = "drop") %>%
    GO_and_KEGG_gsea(keep.all = TRUE, GO_list = "bee_GO") %>% 
    mutate(Time = "Queen", Comparison = "Queen temporal change")
  
  GO_Amel_annotations_temporalW <- time_GO_data %>%         
    filter(Caste == "Worker") %>%
    group_by(gene) %>%
    summarise(statistic = statistic[which.max(abs(statistic))], .groups = "drop") %>%
    GO_and_KEGG_gsea(keep.all = TRUE, GO_list = "bee_GO") %>% 
    mutate(Time = "Worker", Comparison = "Worker temporal change")
  
  significant_q <- GO_Amel_annotations_temporalQ %>% 
    filter(pval < p_thresh) %>% pull(pathway) %>% unique()
  significant_w <- GO_Amel_annotations_temporalW %>% 
    filter(pval < p_thresh) %>% pull(pathway) %>% unique()
  
  GO_Amel_annotations_temporalQ <- GO_Amel_annotations_temporalQ %>%
    filter(pathway %in% unique(c(significant_q, significant_w)))
  GO_Amel_annotations_temporalW <- GO_Amel_annotations_temporalW %>%
    filter(pathway %in% unique(c(significant_q, significant_w)))
  
  # Temporal change, in each caste (D. mel)
  GO_Dmel_annotations_temporalQ <- time_GO_data %>%        
    filter(Caste == "Queen") %>%
    group_by(gene) %>%
    summarise(statistic = statistic[which.max(abs(statistic))], .groups = "drop") %>%
    GO_and_KEGG_gsea(keep.all = TRUE, GO_list = "dros_ortho_GO") %>% 
    mutate(Time = "Queen", Comparison = "Queen temporal change")
  
  GO_Dmel_annotations_temporalW <- time_GO_data %>%        
    filter(Caste == "Worker") %>%
    group_by(gene) %>%
    summarise(statistic = statistic[which.max(abs(statistic))], .groups = "drop") %>%
    GO_and_KEGG_gsea(keep.all = TRUE, GO_list = "dros_ortho_GO") %>% 
    mutate(Time = "Worker", Comparison = "Queen temporal change")
  
  significant_q <- GO_Dmel_annotations_temporalQ %>% filter(pval < p_thresh) %>% pull(pathway) %>% unique()
  significant_w <- GO_Dmel_annotations_temporalW %>% filter(pval < p_thresh) %>% pull(pathway) %>% unique()
  
  GO_Dmel_annotations_temporalQ <- GO_Dmel_annotations_temporalQ %>%
    filter(pathway %in% unique(c(significant_q, significant_w)))
  GO_Dmel_annotations_temporalW <- GO_Dmel_annotations_temporalW %>%
    filter(pathway %in% unique(c(significant_q, significant_w)))
  
  list(GO_Amel_annotations_caste = GO_Amel_annotations_caste, 
       GO_Dmel_annotations_caste = GO_Dmel_annotations_caste,
       GO_Amel_annotations_temporalQ = GO_Amel_annotations_temporalQ, 
       GO_Amel_annotations_temporalW = GO_Amel_annotations_temporalW,
       GO_Dmel_annotations_temporalQ = GO_Dmel_annotations_temporalQ, 
       GO_Dmel_annotations_temporalW = GO_Dmel_annotations_temporalW) %>%
    saveRDS(file = "output/expr_gsea_results.rds")
} else GO_KEGG_results <- readRDS(file = "output/expr_gsea_results.rds")

source("code/make_pathway_figure.R")

do_GO_table <- function(GO_results){
  GO_results %>%
    mutate(leadingEdge = map_chr(leadingEdge, ~ paste0(.x, collapse = ", ")),
           gene_names = map_chr(gene_names, ~ paste0(.x, collapse = ", "))) %>%
    dplyr::select(-ES, -log2err, -Comparison) %>%
    dplyr::select(Time, term, everything()) %>%
    dplyr::rename(Term=term, `Term type` = Test_type, ID = pathway, 
                  `Normalised enrichment score` = NES, 
                  `Leading edge genes` = leadingEdge,
                  `Corresponding gene names` = gene_names) %>%
    my_data_table() %>% formatSignif(c('pval', 'padj', 'Normalised enrichment score'), 2)
}



BP_fig_Amel <- GO_KEGG_results$GO_Amel_annotations_caste %>%
  filter(Test_type == "GO: Biological process") %>%
  make_pathway_figure("", "Hours post-grafting")

BP_tab_Amel <- GO_KEGG_results$GO_Amel_annotations_caste %>%
  filter(Test_type == "GO: Biological process") %>%
  do_GO_table()

MF_fig_Amel <- GO_KEGG_results$GO_Amel_annotations_caste %>%
  filter(Test_type == "GO: Molecular function") %>%
  make_pathway_figure("", "Hours post-grafting")

MF_tab_Amel <- GO_KEGG_results$GO_Amel_annotations_caste %>%
  filter(Test_type == "GO: Molecular function") %>%
  do_GO_table()

CC_fig_Amel <- GO_KEGG_results$GO_Amel_annotations_caste %>%
  filter(Test_type == "GO: Cellular component") %>%
  make_pathway_figure("", "Hours post-grafting")

CC_tab_Amel <- GO_KEGG_results$GO_Amel_annotations_caste %>%
  filter(Test_type == "GO: Cellular component") %>%
  do_GO_table()

kegg_fig_Amel <- GO_KEGG_results$GO_Amel_annotations_caste %>%
  filter(Test_type == "KEGG") %>%
  make_pathway_figure("", "Hours post-grafting")

kegg_tab_Amel <- GO_KEGG_results$GO_Amel_annotations_caste %>%
  filter(Test_type == "KEGG") %>%
  do_GO_table()

BP_fig_Dmel <- GO_KEGG_results$GO_Dmel_annotations_caste %>%
  filter(Test_type == "GO: Biological process") %>%
  make_pathway_figure("", "Hours post-grafting")

BP_tab_Dmel <- GO_KEGG_results$GO_Dmel_annotations_caste %>%
  filter(Test_type == "GO: Biological process") %>%
  do_GO_table()

MF_fig_Dmel <- GO_KEGG_results$GO_Dmel_annotations_caste %>%
  filter(Test_type == "GO: Molecular function") %>%
  make_pathway_figure("", "Hours post-grafting")

MF_tab_Dmel <- GO_KEGG_results$GO_Dmel_annotations_caste %>%
  filter(Test_type == "GO: Molecular function") %>%
  do_GO_table()

CC_fig_Dmel <- GO_KEGG_results$GO_Dmel_annotations_caste %>%
  filter(Test_type == "GO: Cellular component") %>%
  make_pathway_figure("", "Hours post-grafting")

CC_tab_Dmel <- GO_KEGG_results$GO_Dmel_annotations_caste %>%
  filter(Test_type == "GO: Cellular component") %>%
  do_GO_table()

kegg_fig_Dmel <- GO_KEGG_results$GO_Dmel_annotations_caste %>%
  filter(Test_type == "KEGG") %>%
  make_pathway_figure("", "Hours post-grafting")

kegg_tab_Dmel <- GO_KEGG_results$GO_Dmel_annotations_caste %>%
  filter(Test_type == "KEGG") %>%
  do_GO_table()
```

### GO and KEGG enrichment using _A. mellifera_ annotations {.tabset}

Red means relatively higher expression of the focal pathway/process in queens, blue means higher in workers. Calculated separately for each of the 4 time points. A single asterisk indicates statistically significant enrichment, and a double asterisk indicates that this significant result remained after Benjamini-Hochberg false discovery rate correction (which is overly conservative here, since these multiple tests are not independent).


#### GO: Biological process {.tabset}

##### Figure
```{r enrichBP, fig.height=10, fig.width = 5.3}
BP_fig_Amel
```

##### Table
```{r}
BP_tab_Amel
```


#### GO: Molecular function {.tabset}

##### Figure
```{r enrichMF, fig.height=10, fig.width = 5.3}
MF_fig_Amel
```

##### Table
```{r}
MF_tab_Amel
```

#### GO: Cellular component {.tabset}

##### Figure
```{r enrichCC, fig.width = 5.3}
CC_fig_Amel
```

##### Table
```{r}
CC_tab_Amel
```

#### KEGG {.tabset}

##### Figure
```{r enrichKEGG, fig.height=14, fig.width = 5.3}
kegg_fig_Amel
```

##### Table
```{r}
kegg_tab_Amel
```

### GO and KEGG enrichment using _D. melanogaster_ annotations {.tabset}

Red means relatively higher expression of the focal pathway/process in queens, blue means higher in workers. Calculated separately for each of the 4 time points. A single asterisk indicates statistically significant enrichment, and a double asterisk indicates that this significant result remained after Benjamini-Hochberg false discovery rate correction (which is overly conservative here, since these multiple tests are not independent).

#### GO: Biological process {.tabset}

##### Figure
```{r enrichBPmel, fig.height=35, fig.width = 5.3}
BP_fig_Dmel
```

##### Table
```{r}
BP_tab_Amel
```

#### GO: Molecular function {.tabset}

##### Figure
```{r enrichMFmel, fig.height=25, fig.width = 5.3}
MF_fig_Dmel
```

##### Table
```{r}
MF_tab_Dmel
```

#### GO: Cellular component {.tabset}

##### Figure
```{r enrichCCmel, fig.height=17, fig.width = 5.3}
CC_fig_Dmel
```

##### Table
```{r}
CC_tab_Dmel
```

#### KEGG {.tabset}

##### Figure
```{r enrichKEGGmel, fig.height=11, fig.width = 5.3}
kegg_fig_Dmel
```

##### Table
```{r}
kegg_tab_Dmel
```


## Gene coexpression network analysis

### Build the network using `WGCNA::blockwiseModules()`

```{r make_network, results='hide', warning=FALSE, message=FALSE}
if(!file.exists("output/expression_eigengenes.csv")){
  build_network <- function(expression_data){
    
    # We need samples=rows, columns= genes (opposite of limma!)
    my_data <- t(expression_data)
    for(i in ncol(my_data)) my_data[,i] <- as.numeric(my_data[,i])   # needed to convert from integers for a WGCNA function to work! 
    
    # Pick the soft thresholding power that gives a model fit of 
    # R^2 > RsquaredCut for the scale-free topology model
    soft_power <- pickSoftThreshold(
      my_data, powerVector = 1:30, RsquaredCut = 0.85, verbose = 5)
    
    print(paste("Network was built using a soft thresholding power of", 
                soft_power$powerEstimate))
    
    cor <- WGCNA::cor # 
    
    # Use this power to generate a gene co-expression network
    # Largely uses the default arguments, except as stated:
    blockwiseModules(
      my_data, 
      power = soft_power$powerEstimate,
      networkType = "signed",
      minModuleSize = 30,
      verbose = 0,
      saveTOMs = FALSE)
  }
  
  
  # By default, WGCNA gives the transcriptional modules arbitrary names like 'turqoise' or 'darkred'. 
  # I think it's more sensible to name the biggest module as 'Module 1', the second biggest as 'Module 2', etc
  # I use the label 'Module 0' for genes that were not assigned to a module (usually labelled 'grey' by WGCNA)
  convert_colors_to_numbers <- function(network){
    module_sizes <- table(network$colors) %>% sort() %>% rev()
    module_sizes <- c(module_sizes[names(module_sizes) == "grey"], 
                      module_sizes[names(module_sizes) != "grey"])
    module_mappings <- data.frame(
      color = names(module_sizes), 
      new_name = paste("Module", 
                       0:(length(module_sizes)-1)), stringsAsFactors = F)
    
    # Edit the colours of each gene to module names
    network$colors <- module_mappings$new_name[
      match(network$colors, module_mappings$color)]
    network$colors <- factor(network$colors, module_mappings$new_name)
    # Edit the corresponding module eigengenes
    names(network$MEs) <- module_mappings$new_name[
      match(gsub("ME", "", names(network$MEs)), module_mappings$color)]
    network$MEs <- network$MEs %>% dplyr::select(!! module_mappings$new_name)
    network
  }
  
  # Rearrange the data in a handy format for stats and plotting
  rearrange_eigengene_data <- function(network, sample_ids){
    n_modules <- ncol(network$MEs)
    
    sample_ids$sample <- gsub("queen", "q", sample_ids$sample)
    sample_ids$sample <- gsub("worker", "w", sample_ids$sample)
    
    firstup <- function(x) {
      substr(x, 1, 1) <- toupper(substr(x, 1, 1))
      x}
    
    network$MEs %>% 
      rownames_to_column("sample") %>%
      left_join(sample_ids, by = "sample") %>%
      gather(Module, Eigengene, starts_with("Module")) %>%
      mutate(Module = factor(Module,
                             levels = paste("Module", 0:(n_modules - 1)))) %>%
      rename_all(~ firstup(.x)) %>%
      dplyr::rename(Time = Time_point) %>%
      arrange(Module, Caste, Time) %>% as_tibble()
  }
  
  network <- expression_data %>%
    build_network() %>% 
    convert_colors_to_numbers()
  
  expr_eigengenes <- network %>% 
    rearrange_eigengene_data(sample_ids = sample_ids)
  
  connectivity <- data.frame(
    Gene = rownames(expression_data),
    intramodularConnectivity.fromExpr(
      t(expression_data), 
      network$colors, 
      networkType = "signed", 
      scaleByMax = FALSE,
      ignoreColors = "Module 0",
      getWholeNetworkConnectivity = TRUE))
  
  # Merge module memberships with the differentiatial expression results & save
  caste_results <- caste_results %>%
    left_join(tibble(gene = rownames(expression_data), module = network$colors),
              by = c(`Gene symbol` = "gene"))
  time_results <- time_results %>%
    left_join(tibble(gene = rownames(expression_data), module = network$colors),
              by = c(`Gene symbol` = "gene"))
  
  write_csv(connectivity, path = "output/gene_connectivity.csv")
  write_csv(caste_results, path = "output/caste_results.csv")
  write_csv(time_results, path = "output/time_results.csv")
  write_csv(expr_eigengenes, path = "output/expression_eigengenes.csv")
  saveRDS(network, file = "output/expression_network.rds")
} else {
  expr_eigengenes <- read_csv("output/expression_eigengenes.csv")
  network <- readRDS("output/expression_network.rds")
}
```

### Count the number of genes per module
```{r echo=FALSE}
num_modules <- length(unique(network$colors))
```

The algorithm in WGCNA has grouped the `r length(network$colors)` transcripts into `r num_modules` modules of variable size. Note that Module 0 contains all the transcripts that were not assigned to a module (indicating that their expression did not covary detectably with other genes).
```{r}
network$colors %>% table() %>% pander()
```


### Plot correlations between module eigengenes
Note that some modules show correlated expression with other modules, forming 'meta-modules'. Moreover, we can see that certain modules appear to distinguish queens at later times (e.g. 6h and 8h) from workers, or early-stage queens.

```{r fig.height=9}
brms_data <- expr_eigengenes %>%
  mutate(sample = rep(colnames(expression_data), length(unique(Module)))) %>%
  spread(Module, Eigengene) %>%
  rename_at(vars(starts_with("Module")), ~ gsub("Module ", "m", .x)) %>%
  mutate(Time = as.numeric(as.character(Time)),
         Caste = factor(Caste, c("Queen", "Worker"))) %>%
  mutate(scaled_Time = as.numeric(scale(Time))) %>%
  mutate_at(vars(starts_with("m")), ~ as.numeric(scale(.x))) %>%
  mutate(Replicate = C(factor(Replicate), contr = "contr.sum")) 


mat <- dplyr::select(brms_data, starts_with("m")) %>% 
  rename_all(~ str_replace_all(.x, "m", "Module ")) %>%
  as.matrix()
rownames(mat) <- paste(brms_data$Caste, brms_data$Time, brms_data$Replicate)
rownames(mat) <- str_replace_all(rownames(mat), "NA 0", "t0")
rownames(mat) <- str_replace_all(rownames(mat), "2", "2h")
rownames(mat) <- str_replace_all(rownames(mat), "4", "4h")
rownames(mat) <- str_replace_all(rownames(mat), "6", "6h")
rownames(mat) <- str_replace_all(rownames(mat), "8", "8h")

paletteLength <- 50
myColor <- colorRampPalette(c(brewer.pal(9, "Blues")[6], "white", brewer.pal(9, "Reds")[6]))(paletteLength)
myBreaks <- c(seq(min(mat, na.rm=T), 0, length.out=ceiling(paletteLength/2) + 1), 
              seq(max(mat, na.rm=T)/paletteLength, max(mat, na.rm=T), length.out=floor(paletteLength/2)))

pheatmap(mat, color = myColor, breaks = myBreaks,
         cutree_rows = 5, cutree_cols = 5)
```





### Fit Bayesian model to the eigengene estimates

The following code chunk fits a Bayesian model to the eigenegene estimates produced by `WGCNA`. The 'eigengene' for sample $i$, module $j$, gives a measure of the expression level of all the coexpressed genes that were assigned to module $j$, for sample $i$ relative to other samples. The eigengenes were transformed to have a mean of zero and standard deviation of 1 prior to analysis. 

Because the module eigengenes are somewhat correlated with each other, it is valuable to run a single model of all $j$ module eigengenes (thereby using the information in this correlation), rather than running $j$ univariate models. We therefore ran a single multivariate model encompassing all `r num_modules` modules (including module zero, the unassigned genes).  

Furthermore, we expected a prior that some eigengenes will change non-linearly, for example increasing to a plateau, or increasing then decreasing again, throughout the course of development. We therefore fit the time effect using a thin plate regression line smooth (i.e. we used a generalised additive model) with basis dimension k=4, to allow for a non-linear time effect. To allow for a caste-specific change over time, we fit one smooth for the reference caste (queens), and fit a 'difference smooth' for the other caste to allow it to deviate.

Finally, our experiment was split into 4 replicates/blocks, and so we fit replicate as a random effect to account for similarity in eigengenes between samples measured in the same block, and prevent pseuodreplication.

In `brms` notations (which is similar to e.g. `lme4` and many other R packages), the model formula for each module is written as

$$ y \sim Caste + s(Time, by = Caste, k = 4) + Replicate$$

where $y$ is the eigengene for module $j$. 

```{r}
# Define the model formula for all the j modules
j <- length(unique(expr_eigengenes$Module))
brms_formula <- bf(
  paste("mvbind(",
        paste0(paste("m", 0:(j - 1), 
                     sep = ""), collapse = ","),
        ") ~ Caste + s(Time, by = Caste, k = 4) + Replicate", sep = "") 
) + set_rescor(FALSE)   

mod_levels <- paste("m", 0:(j - 1), sep = "")

brms_data$Sample[str_detect(brms_data$Sample, "t0")] <- paste("t0", brms_data$Replicate[str_detect(brms_data$Sample, "t0")], sep ="")

brms_data <- list(
  brms_data %>% 
    mutate(Caste = replace(Caste, Sample %in% c("t0A", "t0B"), "Queen"),
           Caste = replace(Caste, Sample %in% c("t0C", "t0D"), "Worker")),
  brms_data %>% 
    mutate(Caste = replace(Caste, Sample %in% c("t0A", "t0C"), "Queen"),
           Caste = replace(Caste, Sample %in% c("t0B", "t0D"), "Worker")),
  brms_data %>% 
    mutate(Caste = replace(Caste, Sample %in% c("t0A", "t0D"), "Queen"),
           Caste = replace(Caste, Sample %in% c("t0B", "t0C"), "Worker")), 
  brms_data %>% 
    mutate(Caste = replace(Caste, Sample %in% c("t0B", "t0C"), "Queen"),
           Caste = replace(Caste, Sample %in% c("t0A", "t0D"), "Worker")), 
  brms_data %>% 
    mutate(Caste = replace(Caste, Sample %in% c("t0B", "t0D"), "Queen"),
           Caste = replace(Caste, Sample %in% c("t0A", "t0C"), "Worker")), 
  brms_data %>% 
    mutate(Caste = replace(Caste, Sample %in% c("t0C", "t0D"), "Queen"),
           Caste = replace(Caste, Sample %in% c("t0A", "t0B"), "Worker"))) %>%
  map(~.x %>% rename_all(~ str_replace_all(.x, "Module ", "m")))


run_brms_eigengene_model <- function() {
  brm_multiple(
    brms_formula,
    data = brms_data,
    prior = c(set_prior("normal(0, 2)", class = "b", resp = "m0"),
              set_prior("normal(0, 2)", class = "b", resp = "m1"),
              set_prior("normal(0, 2)", class = "b", resp = "m2"),
              set_prior("normal(0, 2)", class = "b", resp = "m3"),
              set_prior("normal(0, 2)", class = "b", resp = "m4"),
              set_prior("normal(0, 2)", class = "b", resp = "m5"),
              set_prior("normal(0, 2)", class = "b", resp = "m6"),
              set_prior("normal(0, 2)", class = "b", resp = "m7"),
              set_prior("normal(0, 2)", class = "b", resp = "m8"),
              set_prior("normal(0, 2)", class = "b", resp = "m9"),
              set_prior("normal(0, 2)", class = "b", resp = "m10"),
              set_prior("normal(0, 2)", class = "b", resp = "m11"),
              set_prior("normal(0, 2)", class = "b", resp = "m12"),
              set_prior("normal(0, 2)", class = "b", resp = "m13"),
              set_prior("normal(0, 2)", class = "b", resp = "m14"),
              set_prior("normal(0, 2)", class = "b", resp = "m15"),
              set_prior("normal(0, 2)", class = "b", resp = "m16"),
              set_prior("normal(0, 2)", class = "b", resp = "m17"),
              set_prior("normal(0, 2)", class = "b", resp = "m18")), 
    chains = 4, iter = 4000, cores = 1, inits = 0,
    control = list(adapt_delta = 0.9999, max_treedepth = 20))
}

if(!file.exists("output/brms_eigengene_model_expression.rds")){
  brms_eigengene_model <- run_brms_eigengene_model()
  saveRDS(brms_eigengene_model, "output/brms_eigengene_model_expression.rds")
} else brms_eigengene_model <- readRDS("output/brms_eigengene_model_expression.rds")
```





<!-- ```{r} -->
<!-- # OG version: -->
<!-- eigengenes <- read_csv("output/expression_eigengenes.csv") # can delete after testing -->

<!-- # Define the model formula for all the j modules -->
<!-- j <- length(unique(eigengenes$Module)) -->
<!-- brms_formula <- bf( -->
<!--   paste("mvbind(", -->
<!--         paste0(paste("m", 0:(j - 1),  -->
<!--                      sep = ""), collapse = ","), -->
<!--         ") ~ Caste + s(Time, by = Caste, k = 4) + Replicate", sep = "")  -->
<!-- ) + set_rescor(FALSE)    -->

<!-- mod_levels <- paste("Module", 0:(j - 1)) -->

<!-- eigengenes$Time <- as.numeric(as.character(eigengenes$Time)) -->

<!-- brms_data <- eigengenes %>% -->
<!--   dplyr::select(Caste, Time, Replicate, Module, Eigengene) %>% -->
<!--   spread(Module, Eigengene) %>% -->
<!--   rename_all(~ str_replace_all(.x, "Module ", "m")) %>% -->
<!--   mutate(across(starts_with("m"), ~ as.numeric(scale(.x)))) # scale the eigengenes -->

<!-- t0_indexes <- which(brms_data$Caste == "Time zero") -->


<!-- v1 <- brms_data$Caste; v2 <- brms_data$Caste; v3 <- brms_data$Caste -->
<!-- v4 <- brms_data$Caste; v5 <- brms_data$Caste; v6 <- brms_data$Caste -->
<!-- v1[t0_indexes] <- c("Queen", "Queen", "Worker", "Worker") -->
<!-- v2[t0_indexes] <- c("Queen", "Worker", "Queen", "Worker") -->
<!-- v3[t0_indexes] <- c("Queen", "Worker", "Worker", "Queen") -->
<!-- v4[t0_indexes] <- c("Worker", "Queen", "Queen", "Worker") -->
<!-- v5[t0_indexes] <- c("Worker", "Queen", "Worker", "Queen") -->
<!-- v6[t0_indexes] <- c("Worker", "Worker", "Queen", "Queen") -->
<!-- data_permutations <- list( -->
<!--   brms_data %>% mutate(Caste = v1), -->
<!--   brms_data %>% mutate(Caste = v2), -->
<!--   brms_data %>% mutate(Caste = v3), -->
<!--   brms_data %>% mutate(Caste = v4), -->
<!--   brms_data %>% mutate(Caste = v5), -->
<!--   brms_data %>% mutate(Caste = v6)) -->


<!-- # run one model on each relabelled version of the data  -->
<!-- brms_eigengene_model <- brm_multiple( -->
<!--   brms_formula,  -->
<!--   iter = 4000, chains = 1,  -->
<!--   prior = prior(normal(0, 5), class = "b"),  -->
<!--   data = data_permutations) -->
<!-- ``` -->


<!-- ```{r eigen_model, results='hide', warning=FALSE, message=FALSE} -->
<!-- # Define the model formula for all the j modules -->
<!-- j <- length(unique(eigengenes$Module)) -->
<!-- brms_formula <- bf( -->
<!--   paste("mvbind(", -->
<!--         paste0(paste("m", 0:(j - 1),  -->
<!--                      sep = ""), collapse = ","), -->
<!--         ") ~ Time + Caste + Time:Caste + I(Time^2) + I(Time^2):Caste + Replicate", sep = "") # Caste + s(Time, by = Caste, k = 4) + (1 | Replicate) -->
<!-- ) + set_rescor(FALSE)    -->

<!-- mod_levels <- paste("Module", 0:(j - 1)) -->



<!-- run_brms_eigengene_model <- function() { -->
<!--   brm( -->
<!--     brms_formula, -->
<!--     data = brms_data, -->
<!--     prior = c(set_prior("normal(0, 3)", class = "b")),  -->
<!--     chains = 1, iter = 4000, cores = 1, inits = 0, -->
<!--     control = list(adapt_delta = 0.9999, max_treedepth = 20)) -->
<!-- } -->

<!-- if(!file.exists("output/brms_eigengene_model_expression.rds")){ -->

<!--   brms_eigengene_model_chain1 <- run_brms_eigengene_model() -->
<!--   brms_eigengene_model_chain2 <- run_brms_eigengene_model() -->
<!--   brms_eigengene_model_chain3 <- run_brms_eigengene_model() -->
<!--   brms_eigengene_model_chain4 <- run_brms_eigengene_model() -->
<!--   brms_eigengene_model <- combine_models(brms_eigengene_model_chain1, brms_eigengene_model_chain2, -->
<!--                                        brms_eigengene_model_chain3, brms_eigengene_model_chain4) -->
<!--   saveRDS(brms_eigengene_model, "output/brms_eigengene_model_expression.rds") -->
<!-- } else brms_eigengene_model <- readRDS("output/brms_eigengene_model_expression.rds") -->
<!-- ``` -->

### Make Figure X

Plot the model-estimated means for the module expression levels ('eigengenes').

```{r eigen_plot, fig.width=10, fig.height=10, fig.showtext=TRUE, warning=F, message=F}
module_levels <- paste("Module", 0:(length(mod_levels) - 1))

# Data for the raw data point in figure
raw_data <- brms_data[[1]] %>%
  gather(Module, eigengene, starts_with("m")) %>%
  mutate(Module = str_replace_all(Module, "m", "Module "),
         Module = factor(Module, module_levels)) %>%
    mutate(Caste = replace(Caste, Time == 0, NA))


# Define y limits for the figure: 3% either side of the full range of the raw data
ylimits <- c(min(raw_data$eigengene), max(raw_data$eigengene))
range_frac <- 0.03 * (ylimits[2] - ylimits[1])
ylimits <- c(ylimits[1] - range_frac,
             ylimits[2] + range_frac * 1.1) # add a little extra space for gene counts

# Define new data to get the lines and predicted means 
new <- expand_grid(
  Time = seq(0, 8, by = 0.25), 
  Replicate = c("A", "B", "C", "D"),
  Caste = c("Queen", "Worker")) %>%
  mutate(para = paste("V", 1:n(), sep = "")) 

# Function to get all the predictions for each module
make_preds <- function(){
  preds <- fitted(brms_eigengene_model, new, summary = FALSE, re_formula = NA, nsamples = 100) 
  
  map_df(1:length(unique(network$colors)), ~ {
    as.data.frame(preds[,, .x]) %>% 
      mutate(draw = 1:n(),
             Module = paste("Module", .x - 1)) %>% 
      gather(para, eigengene, -draw, -Module)}) %>% 
    left_join(new, by="para") %>% 
    as_tibble() %>%
    mutate(Module = factor(Module, module_levels)) %>%
    group_by(Module, Time, Caste, draw) %>% # average over replicates
    summarise(eigengene = mean(eigengene)) %>%
    mutate(Caste = replace(Caste, Time == 0, NA)) %>%
    distinct()
}
preds <- make_preds()

 
# Calculate the median and Est.Error of the posterior at 0h, 2h, 4h, 6h and 8h in each caste
means_data <- preds %>%
  filter(Time %in% c(0,2,4,6,8)) %>%
  group_by(Module, Caste, Time) %>%
  summarise(stats = list(as.data.frame(posterior_summary(eigengene))),
            .groups = "drop") %>%
  ungroup() %>% unnest(stats) %>% dplyr::rename(eigengene = Estimate)

# Find the posterior estimate of the median fit line
mean_line_data <- preds %>%
  group_by(Module, Caste, Time) %>%
  summarise(stats = list(as.data.frame(posterior_summary(eigengene)))) %>%
  ungroup() %>% unnest(stats) %>% dplyr::rename(eigengene = Estimate)


gene_number_labels <- dplyr::rename(network$colors %>% table() %>% 
  broom::tidy(), Module = `.`) %>%
  mutate(label_text = paste(n, "genes"),
         Time = 8.21, eigengene = 3.5,
         Module = factor(Module, module_levels))

# Make the figure
pd <- position_dodge(0.35)

set.seed(1)
eigen_plot <- preds %>%
#  filter(draw %in% sample(max(preds$draw), 100)) %>% # plot random 100 posterior fit lines
  ggplot(aes(Time, eigengene)) +
  scale_fill_manual(values = c(queen_colour, worker_colour, "white"), 
                    aesthetics = c("colour", "fill"), name = "Cell type") +  
  
  geom_line(alpha = 0.05, size = 0.4,
            aes(colour = Caste, group = paste(draw, Caste))) +
  # Add the median best fit line
  geom_line(data = mean_line_data, size = 0.6, alpha = 0.7,
            aes(colour = Caste, group = Caste)) +
  # Add the raw data points
  geom_point(data = raw_data, aes(fill = Caste),
             size = 0.8, pch = 21, colour = "black", stroke = 0.3, position = pd) + 
  # Add the posterior median +/- error bars
  geom_errorbar(data = means_data, 
                width = 0, colour = "grey20",
                aes(ymin = eigengene - Est.Error, group = Caste,
                    ymax = eigengene + Est.Error), position = pd) +
  geom_point(data = means_data, aes(fill = Caste), 
             pch = 21, size = 2, alpha = 0.7, position = pd) +
  
  geom_text(data = gene_number_labels, aes(label = label_text), 
            size = 2.8, hjust = 1, colour = "grey20", family = nice_font) + 
  facet_wrap(~ Module) + 
  ylab("Relative expression of genes in this module\n(eigengene, posterior estimates)") +
  xlab("Hours post-grafting into queen or worker cell") + 
  
  coord_cartesian(ylim = c(-3.6, 3.6)) +
  theme_bw() + 
  theme(legend.position = "top",
        text = element_text(family = nice_font),
        strip.background = element_rect(fill = "white", colour = "white"))

ggsave(eigen_plot, filename = "figures/eigengenes_expression_network.pdf", width = 8, height = 8)
eigen_plot
```

### Calculate effect sizes for the module eigengenes

**Table SX:** The table shows a summary of the posterior estimate of the difference in mean module eigengenes between queen- and worker-destined larvae at each of the four time points. The estimates are derived from the posterior estimates for a Bayesian multivariate generalised additive mixed model where the response variable for each sample was a length-`r num_modules` vector of eigengenes for the `r num_modules` modules. The model allowed for caste-specific, non-linear changes in module eigengenes over time (see Figure XXX), and fit "Replicate" as a random intercept. The eigengenes were mean-centred and scaled to unit variance, so the units in the 'Caste difference' column can be interpreted as the standardised effect size (Cohen's $d$, where positive values mean higher expression of the module in queens relative to workers). Other columns show the mean deviation of data points from the estimated mean, the 95% credible interval for the mean, and the posterior probability that the true effect size has the opposite sign to the first column (similar to a one-tailed $p$-value).

#### Full stats table
```{r}
my_summary <- function(x) {

    p <- 1 - (as.numeric(bayestestR::p_direction(x)))
    posterior_summary(x) %>% as_tibble() %>%
      mutate(PP = p) %>%
      mutate(` ` = ifelse(PP < 0.1, "~", ""),
             ` ` = replace(` `, PP < 0.05, "\\*"),
             ` ` = replace(` `, PP < 0.01, "**"),
             ` ` = replace(` `, PP < 0.001, "***"),
             ` ` = replace(` `, PP == " ", "")) %>%
      mutate(PP = as.character(round(PP, 4)))
}

eigengene_stats_table_expr <- preds %>%
  filter(Time %in% c(2,4,6,8)) %>%
  group_by(Time, Module, draw) %>%
  summarise(Caste_difference = eigengene[1] - eigengene[2], .groups = "drop") %>% # Q - W
  group_by(Module, Time) %>%
  summarise(stats = list(my_summary(Caste_difference)), .groups = "drop") %>%
  ungroup() %>% unnest(stats) 

write_csv(eigengene_stats_table_expr, "output/eigengene_stats_table_expr.csv")

eigengene_stats_table_expr %>% 
  dplyr::rename(`Caste difference (positive: Q > W)` = Estimate) %>%
  dplyr::select(-Module) %>%
  kable(digits = 3) %>%
  kable_styling(full_width = FALSE) %>%
  pack_rows("Module 0", 1, 4) %>%
  pack_rows("Module 1", 5, 8)  %>%
  pack_rows("Module 2", 9, 12)  %>%
  pack_rows("Module 3", 13, 16)  %>%
  pack_rows("Module 4", 17, 20)  %>%
  pack_rows("Module 5", 21, 24)  %>%
  pack_rows("Module 6", 25, 28)  %>%
  pack_rows("Module 7", 29, 32)  %>%
  pack_rows("Module 8", 33, 36)  %>%
  pack_rows("Module 9", 37, 40)  %>%
  pack_rows("Module 10", 41, 44)  %>%
  pack_rows("Module 11", 45, 48)  %>%
  pack_rows("Module 12", 49, 52)  %>%
  pack_rows("Module 13", 53, 56)  %>%
  pack_rows("Module 14", 57, 60)  %>%
  pack_rows("Module 15", 61, 64)  %>%
  pack_rows("Module 16", 65, 68)  %>%
  pack_rows("Module 17", 69, 72)  %>%
  pack_rows("Module 18", 73, 76) %>%
  scroll_box(height = "300px")
```

#### Summary of significant caste biases

There are 4 worker-biased modules and 9 queen-biased, leaving 6 that did not show a significant caste bias.
```{r warning=F, message=F}
read_csv("output/eigengene_stats_table_expr.csv") %>% 
  split(.$Module) %>% map(~ sign(.x %>% filter(!is.na(X8) & X8 != "~" & Time != 2) %>% pull(Estimate))) %>% 
  map_chr(~ {
    if(length(.x) == 0) return("Unbiased")
    ifelse(unique(.x) == 1, "Queen-biased", "Worker-biased")
    }) %>% 
  enframe("Module", "Direction") %>% 
  mutate(Module = factor(Module, paste("Module", 0:18))) %>%
  arrange(Direction, Module) %>%
  kable() %>% kable_styling(full_width = FALSE)
```


### Identify GO and KEGG terms enriched in each module

```{r GO.and.KEGG.hypergeometric, results = 'hide', warning=FALSE, message=FALSE}
# Code up a hypergeometric test
manual_GO_enrich <- function(
  GO_ID,
  number_genes_in_set_with_focal_GO,
  number_genes_in_universe_with_focal_GO,
  number_genes_in_set,
  number_genes_in_universe){
  
  p <- phyper(
    q = number_genes_in_set_with_focal_GO - 1, 
    m = number_genes_in_universe_with_focal_GO, 
    n = number_genes_in_universe - number_genes_in_universe_with_focal_GO, 
    k = number_genes_in_set, 
    
    lower.tail = FALSE, log.p = FALSE)
  
  prop_in_set  <- number_genes_in_set_with_focal_GO / number_genes_in_set
  prop_in_univ <- number_genes_in_universe_with_focal_GO / number_genes_in_universe
  
  # Log odds ratio: odds that the focal GO is in the set / odds it's in the universe
  enrichment_LOR <- (prop_in_set / (1 - prop_in_set)) /
    (prop_in_univ / (1 - prop_in_univ))
  
  tibble(
    ID = GO_ID,
    GeneRatio = paste(number_genes_in_set_with_focal_GO, 
                      number_genes_in_set, sep="/"), 
    BgRatio = paste(number_genes_in_universe_with_focal_GO, 
                    number_genes_in_universe, sep="/"),
    enrichment_LOR,
    pvalue = p
  )
}


genes_in_module <- function(module_number){
  rownames(expression_data)[network$colors == paste("Module", module_number)] 
}



GO_and_KEGG_hypergeometric <- function(
  gene_set, gene_universe, 
  gene_set_entrez, gene_universe_entrez,
  apis.db, GO_list, 
  min_size, keep_all){
  
  p <- 0.05; if(keep_all) p <- 1
  neatness <- function(x) format(round(x, 4), nsmall = 4) # for rounding
  
  # Define internal GO enrichment function (custom, but testing shows gives identical results as clusterProfiler)
  # However, it works without an Org.db, which we needed due to there being no publicly-available 
  # GO annotations for many of our genes (we supplemented using BLAST2GO)
  GO_enrichment <- function(gene_set,
                            gene_universe,
                            min_size,
                            keep_all){

    # get GO annotations for genes in the focal set/module
    gene_set <- tbl(db, GO_list) %>%
      left_join(tbl(db, "gene_names"), 
                by = c("SYMBOL" = "gene_symbol")) %>%
      dplyr::rename(gene = SYMBOL) %>%
      dplyr::select(gene, GO, gene_name) %>%
      filter(gene %in% gene_set) %>%
      collect(n=Inf) %>%
      distinct() # should already be, add this to double check
    
    #  do the same for the gene universe
    gene_universe <- tbl(db, GO_list) %>%
      left_join(tbl(db, "gene_names"), 
                by = c("SYMBOL" = "gene_symbol")) %>%
      dplyr::rename(gene = SYMBOL) %>%
      dplyr::select(gene, GO, gene_name) %>%
      filter(gene %in% gene_universe) %>%
      collect(n=Inf) %>%
      distinct() # should already be, add this to double check
    
    unique_GOs <- unique(gene_set$GO)
    n_unique_GOs_in_set <- length(unique_GOs)
    module_size <- nrow(gene_set)
    universe_size <- nrow(gene_universe)
    
    output <- map_df(1:n_unique_GOs_in_set, function(i){
      focal_GO <- unique_GOs[i]
      
      x1 <- gene_set %>% filter(GO == focal_GO) %>% nrow()
      if(x1 < min_size) return(NULL)
      x2 <- gene_universe %>% filter(GO == focal_GO) %>% nrow()
      
      manual_GO_enrich(
        GO_ID = focal_GO,
        number_genes_in_set_with_focal_GO = x1,
        number_genes_in_universe_with_focal_GO = x2,
        number_genes_in_set = module_size,
        number_genes_in_universe = universe_size
      )
    }) 
    
    if(!keep_all & nrow(output) > 0) output <- output %>% filter(pvalue < 0.05)
    if(nrow(output)==0) return(NULL)
    
    output %>%
      left_join(tbl(db, "go_meanings") %>% collect(),
                by = c("ID" = "GO")) %>%
      dplyr::rename(Ontology = ontology,
                    Meaning = term) %>%
      dplyr::select(Ontology, ID, Meaning, everything()) %>%
      distinct()
  }
  
  # Define internal KEGG enrichment function (uses clusterProfiler)
  kegg_enrichment <- function(gene_set, gene_universe, 
                              GO_list, min_size, keep_all){
    
    if(GO_list == "dros_ortho_GO"){
      
      gene_set_CG_drosophila <- tibble(SYMBOL = gene_set) %>%
        left_join(tbl(db, "dros_ortho_GO") %>% 
                    dplyr::select(FLYBASECG, SYMBOL) %>% collect(n=Inf),
                  by = "SYMBOL") %>%
        filter(!is.na(FLYBASECG)) %>%
        pull(FLYBASECG) %>% unique()
      
      gene_universe_CG_drosophila <- tibble(SYMBOL = gene_universe) %>%
        left_join(tbl(db, "dros_ortho_GO") %>% 
                    dplyr::select(FLYBASECG, SYMBOL) %>% collect(n=Inf),
                  by = "SYMBOL") %>%
        filter(!is.na(FLYBASECG)) %>%
        pull(FLYBASECG) %>% unique()
      
      gene_set_CG_drosophila <- paste("Dmel_", gene_set_CG_drosophila, sep = "")
      gene_universe_CG_drosophila <- paste("Dmel_", gene_universe_CG_drosophila, sep = "")
      
      result <-  clusterProfiler::enrichKEGG(
        gene = gene_set_CG_drosophila, organism = "dme", keyType = "kegg", pvalueCutoff = p,
        universe = gene_universe_CG_drosophila, minGSSize = min_size, maxGSSize = 500,
        qvalueCutoff = 1, use_internal_data = FALSE, pAdjustMethod = "BH")
    }
    else {
      result <-  clusterProfiler::enrichKEGG(
        gene = gene_set_entrez, organism = "ame", keyType = "kegg", pvalueCutoff = p,
        universe = gene_universe_entrez, minGSSize = min_size, maxGSSize = 500,
        qvalueCutoff = 1, use_internal_data = FALSE, pAdjustMethod = "BH")
    }
    
    if(is.null(result)) return(NULL)
    
    result <- result@result
    is_enriched <- sapply(result$GeneRatio, 
                          function(x) eval(parse(text=x))) > 
      sapply(result$BgRatio, 
             function(x) eval(parse(text=x)))
    result <- result[is_enriched, ] %>% mutate(p.adjust = p.adjust(pvalue, method = "BH"))
    
    if(nrow(result %>% filter(pvalue < p)) == 0) return(NULL)
    if(!keep_all) result <- result %>% filter(pvalue < 0.05)
    
    data.frame(Ontology = "KEGG", result, stringsAsFactors = FALSE)
  }
  
  kegg_result <- kegg_enrichment(gene_set, gene_universe, GO_list, min_size, keep_all) 
  
  if(!is.null(kegg_result)){
    kegg_result <- kegg_result %>%
      dplyr::rename(Meaning = Description) %>%
      mutate(
        prop_in_set  = sapply(lapply(strsplit(GeneRatio, split = "/"), as.numeric), 
                              function(x) (x[1]) / x[2]),
        prop_in_univ = sapply(lapply(strsplit(BgRatio, split = "/"), as.numeric), 
                              function(x) x[1] / x[2]),
        enrichment_LOR = (prop_in_set / (1 - prop_in_set)) / (prop_in_univ / (1 - prop_in_univ))) %>%
      dplyr::select(Ontology, ID, Meaning, GeneRatio, BgRatio, enrichment_LOR, pvalue) 
  }
  
  kegg_result %>%
    bind_rows(GO_enrichment(gene_set, gene_universe, min_size, keep_all))
}

make_module_GO_table <- function(
  eigengenes, GO_list,
  min_size = 5, keep_all = FALSE){

  n_modules <- eigengenes$Module %>% unique() %>% length()
  module_vec <- 0:(n_modules-1)
  
  add_name_col <- function(df){
    df$gene_names <- map_chr(
      df$geneID, 
      ~ paste0(converter$gene_name[match(.x, converter$entrez_id)], 
               collapse = "; "))
    df %>% mutate(geneID = map_chr(geneID, function(x) paste0(x, collapse = " ")))
  }
  
  converter <- tbl(db, "gene_names") %>% collect(n=Inf) %>%
    filter(gene_symbol %in% rownames(expression_data))
  
  hub <- AnnotationHub::AnnotationHub()
  select <- dplyr::select # wish this worked :(
  rename <- dplyr::rename
  filter <- dplyr::filter
  apis.db <- hub[["AH81619"]]
  
  gene_universe <- rownames(expression_data)
  
  gene_universe_entrez <- converter$entrez_id[
    converter$gene_symbol %in% gene_universe] %>% 
    as.character() 
  
  map_df(module_vec, function(i) { 
    
    print(paste("Doing", i, "/", n_modules, "modules"))
    
    # Entrez IDs of the genes in the focal module
    gene_set <- genes_in_module(i)
    gene_set_entrez <- converter$entrez_id[
      converter$gene_symbol %in% gene_set] %>% 
      as.character()
    
    GO_and_KEGG_hypergeometric(
      gene_set = gene_set, 
      gene_universe = gene_universe, 
      gene_set_entrez = gene_set_entrez, 
      gene_universe_entrez = gene_universe_entrez,
      apis.db = apis.db,
      GO_list = GO_list,
      min_size = min_size,
      keep_all = keep_all) %>% 
      as_tibble() %>% 
      mutate(Module = paste("Module", i)) %>%
      dplyr::select(Module, everything())}) %>%
      mutate(Ontology = replace(Ontology, Ontology == "BP", "GO: BP"),
             Ontology = replace(Ontology, Ontology == "MF", "GO: MF"),
             Ontology = replace(Ontology, Ontology == "CC", "GO: CC"))
}





module_enrichment_plot <- function(df, is.KEGG = FALSE){
  label <- "Name of GO term"
  if(is.KEGG) label <- "Name of KEGG term"
  df %>% 
    arrange(Module, enrichment_LOR) %>% 
    mutate(Meaning = factor(Meaning, unique(Meaning)),
           Ontology = factor(
             Ontology, c("GO: Biological process", 
                          "GO: Molecular function", 
                          "GO: Cellular component", "KEGG"))) %>%
    ggplot(aes(Meaning, enrichment_LOR)) + 
    geom_bar(stat = "identity", colour = "grey10", fill = "#0CE3AC") + # aes(fill = sig), 
    facet_wrap(~Module) + 
    scale_fill_brewer(palette = "Accent", direction = -1) + 
    scale_x_discrete(labels = function(x) str_wrap(x, width = 60)) +
    theme_bw() +
    theme(legend.position = "none", 
          strip.background = element_blank(), 
          strip.text = element_text(size = 10)) + 
    ylab("Enrichment (log odds ratio)") + xlab(label) + 
    coord_flip() 
}  

module_GO_table_amel <- make_module_GO_table(expr_eigengenes, GO_list = "bee_GO") 
module_GO_table_dmel <- make_module_GO_table(expr_eigengenes, GO_list = "dros_ortho_GO")  
```


### Tables of the module enrichment results

Click the buttons to view or export these results.

#### Using _A. mellifera_ annotations

```{r}
present_module_GO_table <- function(module_GO_tbl){
  
  focal <- module_GO_tbl %>%
    arrange(Module, Ontology, pvalue) %>%
    filter(pvalue < 0.05)  %>%
    mutate(`Gene & Background ratios` = paste(GeneRatio, BgRatio),
           ID = paste(Meaning, " (", ID, ")", sep = "")) %>%
    dplyr::rename(Enrichment = enrichment_LOR) %>%
    dplyr::select(-GeneRatio, -BgRatio, -Meaning) %>%
    dplyr::select(Ontology, ID, `Gene & Background ratios`, everything())
  
  focal %>%
    dplyr::select(Module, everything()) %>%
    mutate_if(is.numeric, ~ round(.x, 3)) 
}
present_module_GO_table(module_GO_table_amel) %>%
  my_data_table()
```


#### Using _D. melanogaster_ annotations

```{r}
present_module_GO_table(module_GO_table_dmel) %>%
  my_data_table()
```



<!-- ### Figures of the module enrichment results {.tabset} -->

<!-- Showing a few of the most caste-biased modules, based on inspection of the eigengenes figure and statistical table. -->

<!-- #### KEGG -->
<!-- ```{r module_enrich1, fig.height = 8, fig.width=9, message=FALSE, warning=FALSE, results='hide'} -->
<!-- #mods <- module_GO_table_dmel$Module -->
<!-- mods <- c("Module 6", "Module 7", "Module 12", "Module 15", "Module 17") -->
<!-- module_KEGG <- module_GO_table_dmel %>%  -->
<!--   filter(Ontology == "KEGG", Module %in% mods) %>%  -->
<!--   module_enrichment_plot(is.KEGG = TRUE) -->
<!-- #ggsave(module_KEGG, file = "figures/Figure 4 - module KEGG.pdf", height = 7, width = 8) -->
<!-- module_KEGG -->
<!-- ``` -->
<!-- <br></br> -->
<!-- **Figure 4**: Results of KEGG pathway enrichment analysis for the genes in each of the three significantly pheromone-sensitive transcriptional modules. The gene universe was defined as all genes for which we found an ortholog in all four species (i.e. the set that was used to discover these co-expressed modules). All KEGG terms shown in green were significantly enriched (p < 0.05), and those shown in purple remained significant after correction for multiple testing. Fold enrichment was calculated as the proportion of genes associated with the focal KEGG term in the module, divided by the equivalent proportion in the gene universe. -->

<!-- #### GO Biological process -->
<!-- ```{r module_enrich2, fig.height = 8, fig.width=9, message=FALSE, warning=FALSE, results='hide'} -->
<!-- fig_S6 <- module_GO_table_dmel %>%  -->
<!--   filter(Ontology == "GO:BP", Module %in% mods) %>%  -->
<!--   module_enrichment_plot()   -->
<!-- # saveRDS(fig_S6, file = "supplement/fig_S6.rds") -->
<!-- fig_S6 -->
<!-- ``` -->
<!-- <br></br> -->
<!-- **Figure SX**: Comparable figure to Figure 4, showing the results of GO: Biological process enrichment analysis instead of KEGG pathways.  -->

<!-- #### GO Molecular function -->
<!-- ```{r module_enrich3, fig.height = 8, fig.width=9, message=FALSE, warning=FALSE, results='hide'} -->
<!-- fig_S7 <- module_GO_table_dmel %>%  -->
<!--   filter(Ontology == "GO:MF", Module %in% mods) %>%  -->
<!--   module_enrichment_plot()   -->
<!-- # saveRDS(fig_S7, file = "supplement/fig_S7.rds") -->
<!-- fig_S7 -->
<!-- ``` -->
<!-- <br></br> -->
<!-- **Figure SX**: Comparable figure to Figure 4, showing the results of GO: Molecular function enrichment analysis instead of KEGG pathways.  -->

<!-- #### GO Cellular component -->
<!-- ```{r module_enrich4, fig.height = 8, fig.width=9, message=FALSE, warning=FALSE, results='hide'} -->
<!-- fig_S8 <- module_GO_table_dmel %>%  -->
<!--   filter(Ontology == "GO:CC", Module %in% mods) %>%  -->
<!--   module_enrichment_plot()   -->
<!-- # saveRDS(fig_S8, file = "supplement/fig_S8.rds") -->
<!-- fig_S8 -->
<!-- ``` -->
<!-- <br></br> -->
<!-- **Figure SX**: Comparable figure to Figure 4, showing the results of GO: Cellular component enrichment analysis instead of KEGG pathways. Module 9 is missing because no GO:CC terms were significantly enriched. -->


